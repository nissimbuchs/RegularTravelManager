# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

RegularTravelManager is a Swiss employee travel allowance management system built with Angular 17+, Node.js Lambda functions, and AWS services. The project uses a **LocalStack development environment** providing 95% AWS production parity for local development.

## ğŸš€ Live Application Access

**Development Environment (AWS Dev Stack):**
- **Frontend Application**: https://dz57qvo83kxos.cloudfront.net
- **API Endpoint**: https://1kkd1bbkmh.execute-api.eu-central-1.amazonaws.com/dev/
- **Database**: `rtm-dev-infrastructure-databaseb269d8bb-ynfofwwlfkkm.c18k2mga4rnh.eu-central-1.rds.amazonaws.com`
- **Cognito User Pool**: `eu-central-1_LFA9Rhk2y`

**Staging Environment âœ…:**
- **Frontend Application**: https://rtfm-staging.buchs.be (corrected subdomain)
- **API Endpoint**: https://api-staging.buchs.be
- **CloudFront Distribution**: d23i41oue7n59b.cloudfront.net (will be updated after deployment)
- **SSL Certificates**: Cross-region certificates in us-east-1 for CloudFront compatibility
- **Custom Domains**: External DNS validation with Hostpoint provider

## ğŸŒ Stable CNAME Architecture (NEW)

RegularTravelManager now uses a **persistent global CloudFront distribution** that provides stable CNAME targets for your custom domains. This means you set up your DNS records **once** and they never need to change, even when you destroy and redeploy the API Gateway or Web stacks.

### Architecture Overview

```
Your DNS Records (ONE-TIME SETUP):
rtfm-staging.buchs.be  CNAME  d123xyz.cloudfront.net (stable)
api-staging.buchs.be   CNAME  d123xyz.cloudfront.net (stable)

Global CloudFront (Persistent):
â”œâ”€â”€ Behavior: / â†’ S3 Website Origin (auto-updates)
â”œâ”€â”€ Behavior: /api/* â†’ API Gateway Origin (auto-updates)
â””â”€â”€ SSL Certificate for both domains

Disposable Stacks (Can be destroyed freely):
â”œâ”€â”€ API Gateway â†’ Stores domain in SSM parameters
â””â”€â”€ Web (S3) â†’ Stores website domain in SSM parameters
```

### Key Benefits

- âœ… **Stable CNAME Records**: Set once, never change
- âœ… **Free Redeployments**: API Gateway and Web stacks fully disposable
- âœ… **Automatic Origin Updates**: SSM parameters sync origins to global stack
- âœ… **Zero DNS Maintenance**: No more manual CNAME record updates
- âœ… **Multi-Environment**: Works for dev, staging, and production

### Deployment Order

The global stack deployment depends on SSM parameters from other stacks but has no hard CloudFormation dependencies, allowing full stack disposal:

```
Infrastructure â†’ Lambda â†’ API Gateway â†’ Web â†’ Global
    â†“              â†“           â†“           â†“        â†“
Database,     Functions   API Routes    S3 +   CloudFront
Cognito       + Auth      + Domains   Website   + Origins
```

## Development Commands

### ğŸ¯ Development + 3 Deployment Environments (IaC-Compliant)
This project uses a clear separation between development and deployment:

**Development Environment:**
- **`local`** - Fast development with Docker Compose (no deployment needed)

**AWS Deployment Environments:**
- **`dev`** - AWS development deployment (CDK + Lambda + S3)
- **`staging`** - AWS staging deployment (CDK + Lambda + S3)
- **`production`** - AWS production deployment (CDK + Lambda + S3)

**Build Once, Deploy Everywhere**: The same production-optimized build artifact is deployed to all AWS environments, with environment-specific configuration injected at deployment time.

### Quick Start

**For Local Development** (recommended for daily work):
```bash
# Complete local development setup (< 15 minutes)
npm run setup:local       # Start Docker services + initialize environment
npm run start:local       # Start API & web apps from source code
./test-setup.sh          # Verify environment health
```

**For AWS Deployment** (testing in cloud environment):
```bash
# Deploy to AWS development environment
npm run build            # Create production-optimized build
npm run deploy:dev       # Deploy to AWS dev environment
```

### Build Commands (IaC-Compliant)
```bash
# Single build artifact for all environments
npm run build             # Build entire project (production-optimized)

# Component-specific builds
npm run build:packages    # Build shared packages only
npm run build:apps        # Build API and web applications only
npm run build:frontend    # Build web application only
npm run build:infrastructure # Build AWS CDK infrastructure only
```

**ğŸ¯ IaC Best Practice**: Building is environment-independent. The same build artifact is deployed to all environments (dev, staging, production) with environment-specific configuration injected at deployment/runtime.

**Runtime Configuration**: The web application loads environment-specific configuration from `/assets/config/config.json`, which is generated by the CDK during deployment. This ensures true portability - the same build can run in any environment.

### Deploy Commands (AWS Environments)

#### ğŸŒ Stable CNAME Deployment Commands

```bash
# ğŸš€ Complete fresh deployment (first time or after full destruction)
npm run deploy:full:dev        # Deploy all stacks in correct order + global CloudFront
npm run deploy:full:staging    # Deploy all stacks in correct order + global CloudFront
npm run deploy:full:production # Deploy all stacks in correct order + global CloudFront

# ğŸ”„ Standard deployments (when stacks already exist)
npm run deploy:dev        # Deploy all stacks including global CloudFront
npm run deploy:staging    # Deploy all stacks including global CloudFront
npm run deploy:production # Deploy all stacks including global CloudFront

# ğŸ¯ Origin updates (after recreating API Gateway or Web stacks)
npm run deploy:origins:dev        # Update global CloudFront origins from SSM
npm run deploy:origins:staging    # Update global CloudFront origins from SSM
npm run deploy:origins:production # Update global CloudFront origins from SSM

# ğŸŒ Global stack only (for certificate or origin updates)
npm run deploy:global-only:dev        # Deploy only persistent CloudFront
npm run deploy:global-only:staging    # Deploy only persistent CloudFront
npm run deploy:global-only:production # Deploy only persistent CloudFront
```

#### ğŸ“‹ Individual Stack Deployment
```bash
# Individual stack deployment (from infrastructure workspace)
cd infrastructure
npm run deploy:stack:infrastructure:dev # Deploy core infrastructure only
npm run deploy:stack:lambda:dev        # Deploy Lambda functions only
npm run deploy:stack:api:dev           # Deploy API Gateway only (stores domain in SSM)
npm run deploy:stack:web:dev           # Deploy S3 website only (stores domain in SSM)
npm run deploy:stack:global:dev        # Deploy global CloudFront (reads from SSM)

# Cross-environment commands
npm run deploy:stack:certificate:dev   # Deploy SSL certificates (us-east-1)
npm run deploy:web:dev                 # Deploy web + certificate bundle
```

#### ğŸ—‘ï¸ Stack Destruction (Now Safe!)
```bash
# âœ… You can now safely delete individual stacks without breaking DNS:
aws cloudformation delete-stack --stack-name rtm-staging-api-gateway
aws cloudformation delete-stack --stack-name rtm-staging-web

# âœ… Global CloudFront continues working with fallback origins
# âœ… Redeploy stacks and run npm run deploy:origins:staging to restore

# Full environment destruction
npm run destroy:dev     # Destroy all stacks including global
npm run destroy:staging # Destroy all stacks including global
npm run destroy:production # Destroy all stacks including global
```

**IaC Deployment Flow**:
1. `npm run build` - Creates single production-optimized artifact
2. `npm run deploy:dev` - Deploys same artifact to dev with dev config
3. `npm run deploy:staging` - Deploys same artifact to staging with staging config
4. `npm run deploy:production` - Deploys same artifact to production with production config

### Development vs Deployment Environments

**Local Development** (Fast Iteration):
- **Purpose**: Rapid development and debugging
- **Architecture**: Docker Compose + Direct Node.js execution
- **Services**: PostgreSQL, Redis, LocalStack (mocked AWS)
- **Commands**: `setup:local`, `start:local`
- **Benefits**: Instant reload, debugging, fast feedback loop
- **No deployment needed** - code runs directly from source

**AWS Deployment** (Production Testing):
- **Purpose**: Production-like testing and actual hosting
- **Architecture**: CDK + Lambda + S3 + CloudFront + Real AWS services
- **Services**: RDS, Cognito, SES, CloudFront, API Gateway
- **Commands**: `build`, `deploy:dev/staging/production`
- **Benefits**: Production parity, performance testing, real infrastructure
- **Deployment required** - infrastructure must be provisioned

### Local Development Commands
```bash
# Start applications
npm run start:local       # Start API & web apps in parallel
npm run start:local:api   # Start API server only
npm run start:local:web   # Start Angular app only

# Environment management
npm run env:local         # Start infrastructure services (Docker)
npm run env:local:setup   # Complete environment setup
npm run env:local:logs    # View service logs
npm run env:local:restart # Clean restart with complete setup
npm run env:local:clean   # Stop and remove all containers

# Setup commands
npm run setup:local       # Complete setup + start environment
```

### AWS/LocalStack Commands
```bash
npm run aws:local:start   # Start LocalStack with initialization
npm run aws:local:status  # Check LocalStack health
npm run aws:local:init    # Initialize LocalStack services
```

### Database Commands (Local Environment)
```bash
npm run db:setup:local    # Run migrations + load sample data
npm run db:migrate:local  # Run database migrations only
npm run db:seed:local     # Load comprehensive sample data only
npm run db:reset:local    # Reset database and reload (âš ï¸ Removes all data)
npm run db:validate:local # Validate sample data integrity
npm run db:status:local   # Check migration status
```

### Test Commands (Local Environment)
```bash
npm run test:local        # All tests in local environment
npm run test:integration:local # Integration tests against LocalStack
npm run test:e2e:local    # E2E tests in local environment
```

### Utility Commands
```bash
npm run clean             # Clean build artifacts and cache
npm run lint              # Run ESLint with auto-fix
npm run format            # Format code with Prettier
npm run type-check        # TypeScript type checking
npm run debug:api         # Start API in debug mode
```

## Frequently Asked Questions

### Why is there no `deploy:local` command?

**Answer**: Local development and AWS deployment use fundamentally different architectures:

- **Local development** runs code directly from source using Docker Compose for fast iteration
- **AWS deployment** uses CDK to provision Lambda functions, S3 buckets, and cloud infrastructure

**Local workflow** (no deployment):
```bash
npm run setup:local  # Start Docker services
npm run start:local  # Run from source code - instant changes
```

**AWS workflow** (requires deployment):
```bash
npm run build        # Create production artifacts
npm run deploy:dev   # Deploy to AWS infrastructure
```

This separation provides:
- âš¡ **Fast local development** - no build/deploy cycle needed
- ğŸ—ï¸ **Production-like AWS testing** - real infrastructure deployment
- ğŸ¯ **Clear separation** - development vs deployment concerns

If you need to test the deployment process locally, you can use `npm run build` to verify the build works, then deploy to the AWS dev environment for infrastructure testing.

## Architecture

### Local Development Stack
- **PostgreSQL** (port 5432) â†’ AWS RDS in production
- **Redis** (port 6379) â†’ AWS ElastiCache in production
- **LocalStack** (port 4566) â†’ AWS Services in production
  - S3 (document storage)
  - Location Service (mocked)

### Technology Stack
- **Frontend**: Angular 17+ with TypeScript, Angular Material UI
- **Backend**: Node.js 20+ with TypeScript, Lambda functions
- **Database**: PostgreSQL 15 with PostGIS extension
- **Infrastructure**: AWS CDK 2.100+ in TypeScript
- **Development**: Docker Compose + LocalStack for AWS parity

### AWS CDK Architecture (5-Stack Design)

The infrastructure is organized into 5 independent CDK stacks for better separation of concerns and deployment flexibility:

```
1. InfrastructureStack (rtm-{env}-infrastructure)
   â””â”€â”€ Core backend resources: VPC, RDS, Cognito, Location Service, SES, SNS
   â””â”€â”€ Region: eu-central-1 (Swiss data residency)
   â””â”€â”€ Exports: User Pool ID, Database endpoints, SNS Topic ARN

2. LambdaStack (rtm-{env}-lambda)
   â””â”€â”€ All Lambda functions and their configurations
   â””â”€â”€ Region: eu-central-1
   â””â”€â”€ Depends on: InfrastructureStack (for VPC, database, etc.)
   â””â”€â”€ Exports: ~30 Lambda function ARNs

3. ApiGatewayStack (rtm-{env}-api-gateway)
   â””â”€â”€ REST API, routes, Lambda integrations, API custom domain
   â””â”€â”€ Region: eu-central-1
   â””â”€â”€ Depends on: LambdaStack (imports Lambda ARNs)
   â””â”€â”€ Exports: API Gateway URL

4. CertificateStack (rtm-{env}-certificate) â­ NEW
   â””â”€â”€ SSL certificates for CloudFront distribution
   â””â”€â”€ Region: us-east-1 (CloudFront requirement)
   â””â”€â”€ Cross-region references enabled
   â””â”€â”€ Exports: Certificate ARN for CloudFront

5. WebStack (rtm-{env}-web)
   â””â”€â”€ Frontend hosting: S3, CloudFront, web deployment
   â””â”€â”€ Region: eu-central-1
   â””â”€â”€ Depends on: ApiGatewayStack + InfrastructureStack + CertificateStack
   â””â”€â”€ Uses cross-region certificate from us-east-1
   â””â”€â”€ Exports: CloudFront domain URL
```

**Benefits of this architecture:**
- **Independent deployments**: Update frontend without touching backend
- **Cross-region compliance**: CloudFront certificates in us-east-1, data in eu-central-1
- **Clear dependencies**: No circular dependencies
- **Better CI/CD**: Each stack can have its own deployment pipeline
- **Cost optimization**: Destroy/recreate individual stacks as needed
- **DNS flexibility**: External DNS validation with any provider (Hostpoint, etc.)

### Key Service Configurations
```typescript
// Environment auto-detection
const isLocal = process.env.NODE_ENV === 'development';
const awsEndpoint = isLocal ? 'http://localhost:4566' : undefined;

// Local Database connection
DATABASE_URL: 'postgresql://nissim:devpass123@localhost:5432/travel_manager_dev'

// Production Database connection (AWS RDS)
DATABASE_URL: 'postgresql://rtm_admin:[SECRET]@rtm-dev-infrastructure-databaseb269d8bb-ynfofwwlfkkm.c18k2mga4rnh.eu-central-1.rds.amazonaws.com:5432/rtm_database'

// Cross-region SSL Certificate Configuration
// CloudFront requires certificates in us-east-1 region
const certificateStack = new CertificateStack(app, 'rtm-staging-certificate', {
  env: { region: 'us-east-1' }, // Required for CloudFront
  crossRegionReferences: true   // Enable cross-region access
});
```

## Development Guidelines

### Before Starting Development
1. **Always run environment health check**: `./test-setup.sh`
2. **Check service logs if issues arise**: `npm run env:local:logs`
3. **Use LocalStack for all AWS operations in development**
4. **Code should work identically in local and AWS deployment environments**

### ğŸ”¥ CRITICAL: API Response Pattern (MANDATORY)
**ALL API endpoints MUST use the centralized formatResponse pattern:**

**Backend (Lambda Handlers):**
```typescript
// âœ… ALWAYS DO THIS
import { formatResponse } from '../../middleware/response-formatter';

export const myHandler = async (event, context) => {
  // Success response
  return formatResponse(200, { users: [...] }, context.awsRequestId);

  // Error response
  return formatResponse(404, { code: 'NOT_FOUND', message: 'User not found' }, context.awsRequestId);
};

// âŒ NEVER manually build responses
return {
  statusCode: 200,
  body: JSON.stringify({ success: true, data: users })
};
```

**Frontend (Angular Services):**
```typescript
// âœ… ALWAYS expect data-wrapped responses
this.http.get<{data: UserType}>('/api/users').pipe(
  map(response => response.data)
)

// âŒ NEVER expect direct responses
this.http.get<UserType>('/api/users')
```

**Response Structure:**
- Success: `{ success: true, data: T, timestamp, requestId }`
- Error: `{ success: false, error: {...}, timestamp, requestId }`

### When Adding New Features
- **MANDATORY: Use formatResponse() for all API responses** - see pattern above
- **Use existing AWS service factory** in `apps/api/src/services/aws-factory.ts`
- **Add tests that run against LocalStack services**
- **Update environment configuration if new services needed**
- **Verify changes work in both local development and AWS deployment modes**

### Troubleshooting
- **Services not starting**: `npm run env:local:restart`
- **LocalStack issues**: `docker logs rtm-localstack`
- **Database issues**: `docker logs rtm-postgres`
- **Reset everything**: `npm run env:local:clean && npm run env:local && npm run aws:local:init`

## File Structure

```
RegularTravelManager/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ api/                 # Node.js Lambda functions
â”‚   â””â”€â”€ web/                 # Angular frontend
â”œâ”€â”€ infrastructure/          # AWS CDK infrastructure code
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ infrastructure-stack.ts  # Core infrastructure (eu-central-1)
â”‚   â”‚   â”œâ”€â”€ lambda-stack.ts          # Lambda functions (eu-central-1)
â”‚   â”‚   â”œâ”€â”€ api-gateway-stack.ts     # API Gateway (eu-central-1)
â”‚   â”‚   â”œâ”€â”€ certificate-stack.ts     # SSL certificates (us-east-1) â­ NEW
â”‚   â”‚   â”œâ”€â”€ web-stack.ts             # Frontend hosting (eu-central-1)
â”‚   â”‚   â””â”€â”€ config/environment-config.ts  # Environment configuration
â”‚   â””â”€â”€ package.json         # Deployment scripts
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture.md      # Complete architecture documentation
â”‚   â””â”€â”€ DEVELOPMENT_SETUP.md # Detailed setup guide
â”œâ”€â”€ localstack/
â”‚   â””â”€â”€ init/               # LocalStack initialization scripts
â”œâ”€â”€ docker-compose.yml      # Development infrastructure
â””â”€â”€ test-setup.sh          # Environment verification script
```

## Development Authentication & Sample Data

### Comprehensive Sample Data
The development environment includes complete Swiss business data with production-matching test users:

**Admin Users (Full System Access):**
| User | Email | Name | Role | Employee ID | City |
|------|-------|------|------|-------------|------|
| **admin1** | admin1@company.ch | Hans Zimmermann | CEO/System Admin | ADM-0001 | ZÃ¼rich |
| **admin2** | admin2@company.ch | Maria Weber | IT Administrator | ADM-0002 | Basel |

**Managers:**
| User | Email | Name | Role | Employee ID | City |
|------|-------|------|------|-------------|------|
| **manager1** | manager1@company.ch | Thomas MÃ¼ller | Regional Manager | MGR-0001 | ZÃ¼rich |
| **manager2** | manager2@company.ch | Sophie Dubois | Regional Manager | MGR-0002 | GenÃ¨ve |

**Employees:**
| User | Email | Name | Role | Employee ID | City |
|------|-------|------|------|-------------|------|
| **employee1** | employee1@company.ch | Anna Schneider | Software Developer | EMP-0001 | Bern |
| **employee2** | employee2@company.ch | Marco Rossi | Project Coordinator | EMP-0002 | Lugano |
| **employee3** | employee3@company.ch | Lisa Meier | Business Analyst | EMP-0003 | St. Gallen |
| **employee4** | employee4@company.ch | Pierre Martin | Marketing Specialist | EMP-0004 | Lausanne |
| **employee5** | employee5@company.ch | Julia Fischer | Technical Consultant | EMP-0005 | Basel |
| **employee6** | employee6@company.ch | Michael Keller | Sales Representative | EMP-0006 | Winterthur |

**Sample Data Includes:**
- 4 Business Projects with varying cost rates (0.65-0.80 CHF/km)
- 8 Subprojects across major Swiss cities with precise coordinates
- 5 Travel Requests covering complete lifecycle (pending, approved, rejected, withdrawn)
- Complete audit trails for status changes and address history
- Realistic Swiss business scenarios and geographic coverage

**User Passwords (AWS Cognito):**
- **Admin Users**: `AdminPass123!Test`
- **Manager Users**: `ManagerPass123!`
- **Employee Users**: `EmployeePass123!`

### User Access

**For Local Development (Mock Auth):**
In the browser console (F12), run:
```javascript
// Admin Users (Full system access)
localStorage.setItem('mockUser', 'admin1');     // Hans Zimmermann (CEO)
localStorage.setItem('mockUser', 'admin2');     // Maria Weber (IT Admin)

// Managers  
localStorage.setItem('mockUser', 'manager1');   // Thomas MÃ¼ller
localStorage.setItem('mockUser', 'manager2');   // Sophie Dubois

// Employees (default: employee1)
localStorage.setItem('mockUser', 'employee1');  // Anna Schneider (Developer)
localStorage.setItem('mockUser', 'employee2');  // Marco Rossi (PM)
localStorage.setItem('mockUser', 'employee3');  // Lisa Meier (BA)
localStorage.setItem('mockUser', 'employee4');  // Pierre Martin (Marketing)
localStorage.setItem('mockUser', 'employee5');  // Julia Fischer (Consultant)
localStorage.setItem('mockUser', 'employee6');  // Michael Keller (Sales)

window.location.reload();
```

**Mock User ID Mapping (UUID format for dev environment):**
- admin1@company.ch â†’ `11111111-1111-1111-1111-111111111111`
- admin2@company.ch â†’ `22222222-2222-2222-2222-222222222222`
- manager1@company.ch â†’ `33333333-3333-3333-3333-333333333333`
- manager2@company.ch â†’ `44444444-4444-4444-4444-444444444444`
- employee1@company.ch â†’ `55555555-5555-5555-5555-555555555555`
- employee2@company.ch â†’ `66666666-6666-6666-6666-666666666666`
- employee3@company.ch â†’ `77777777-7777-7777-7777-777777777777`
- employee4@company.ch â†’ `88888888-8888-8888-8888-888888888888`
- employee5@company.ch â†’ `99999999-9999-9999-9999-999999999999`
- employee6@company.ch â†’ `aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa`

**For Production/AWS Environment:**
Use the email addresses and passwords listed above to log in directly via the Cognito authentication.

### Authentication Architecture
- **Local Development**: Mock authentication with production user data
- **Production/AWS**: AWS Cognito with real user management (deployed and working)
- **LocalStack**: Cognito is Pro feature - uses mock authentication in local development
- **User data**: Consistent across frontend auth service and backend API
- **Test Users**: 10 fully configured users with proper permissions and sample data

## Notes

- **Environment parity**: Local development provides 95% AWS production parity
- **Sample Data**: Comprehensive Swiss business data with admin, manager, and employee users
- **Admin Interface**: Full user and project management capabilities
- **Geographic Coverage**: All major Swiss cities with accurate coordinates and realistic business scenarios
- **Cost savings**: ~â‚¬200/month per developer using LocalStack vs real AWS
- **Setup time**: < 15 minutes for new developers
- **Offline development**: Full development capability without internet
- **Documentation**: See DEVELOPMENT_SETUP.md for detailed troubleshooting
- **Data Validation**: Built-in integrity checks for geographic calculations, business constraints, and audit trails

## Important: Essential Development Files

**âš ï¸ NEVER REMOVE these directories - they are essential development infrastructure:**

- **`.bmad-core/`** - BMAD agent system files for proper development workflow
- **`.claude/commands/BMad/`** - Claude commands directory for development assistance
- **`web-bundles/`** - Essential files for correct development practices

These are **development tooling files**, not project artifacts. Removing them will break the development workflow.

## ğŸŒ DNS Setup & Certificate Management

### One-Time DNS Configuration (Stable CNAME Setup)

After deploying the global stack, you'll get a **persistent CloudFront domain** that never changes. Set up your DNS records once:

#### Staging Environment
```bash
# 1. Deploy global stack first
npm run deploy:full:staging

# 2. Get the persistent CloudFront domain from output:
# "PersistentCloudFrontDomain = d123xyz.cloudfront.net"

# 3. Set up CNAME records in your DNS provider (ONE TIME ONLY):
rtfm-staging  CNAME  d123xyz.cloudfront.net
api-staging   CNAME  d123xyz.cloudfront.net
```

#### Production Environment
```bash
# 1. Deploy global stack first
npm run deploy:full:production

# 2. Get the persistent CloudFront domain from output
# 3. Set up CNAME records (ONE TIME ONLY):
rtfm         CNAME  d456abc.cloudfront.net
api          CNAME  d456abc.cloudfront.net
```

### SSL Certificate Process
1. **Global Certificate**: Single certificate for both web and API domains
2. **Regional Deployment**: Created in us-east-1 region for CloudFront compatibility
3. **DNS Validation**: External DNS provider (Hostpoint) adds CNAME validation records
4. **Cross-Region Access**: CDK's `crossRegionReferences: true` enables access

### Troubleshooting

#### Missing Origins (Dummy Fallbacks)
If you see "Using fallback origins" during global stack deployment:

```bash
# Check which stacks are missing:
aws cloudformation list-stacks --region eu-central-1 --query 'StackSummaries[?contains(StackName, `rtm-staging`)].{Name:StackName,Status:StackStatus}'

# Deploy missing stacks:
npm run deploy:stack:api:staging     # If API Gateway missing
npm run deploy:stack:web:staging     # If Web stack missing

# Update global stack origins:
npm run deploy:origins:staging
```

#### DNS Propagation Issues
```bash
# Check DNS propagation:
dig rtfm-staging.buchs.be
dig api-staging.buchs.be

# Verify CloudFront distribution:
aws cloudfront list-distributions --query 'DistributionList.Items[?contains(Comment, `rtm-staging`)].{Id:Id,Domain:DomainName,Status:Status}'
```

#### Stack Deletion Recovery
```bash
# If you accidentally delete API Gateway or Web stacks:
# 1. Global CloudFront continues working with fallback origins
# 2. Redeploy the missing stacks:
npm run deploy:stack:api:staging
npm run deploy:stack:web:staging

# 3. Update origins in global stack:
npm run deploy:origins:staging
```

- always update the readme.md when you update package.json, aws urls or other readme relevant files
- when you develop software and update existing software, never keep old code or functions for backward compatibility
- we are working on enterprise software. never use workarounds. always document new pattterns or factory usage. consistently use existing implementation pattterns, never add TODO.
- when deploying to aws, set long enough timeouts
- use longer timeouts