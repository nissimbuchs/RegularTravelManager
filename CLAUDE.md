# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

RegularTravelManager is a Swiss employee travel allowance management system built with Angular 17+, Node.js Lambda functions, and AWS services. The project uses a **LocalStack development environment** providing 95% AWS production parity for local development.

## 🚀 Live Application Access

**Development Environment (AWS Dev Stack):**
- **Frontend Application**: https://dz57qvo83kxos.cloudfront.net
- **API Endpoint**: https://1kkd1bbkmh.execute-api.eu-central-1.amazonaws.com/dev/
- **Database**: `rtm-dev-infrastructure-databaseb269d8bb-ynfofwwlfkkm.c18k2mga4rnh.eu-central-1.rds.amazonaws.com`
- **Cognito User Pool**: `eu-central-1_LFA9Rhk2y`

**Staging Environment ✅:**
- **Frontend Application**: https://rtfm-staging.buchs.be (corrected subdomain)
- **API Endpoint**: https://api-staging.buchs.be
- **CloudFront Distribution**: d23i41oue7n59b.cloudfront.net (will be updated after deployment)
- **SSL Certificates**: Cross-region certificates in us-east-1 for CloudFront compatibility
- **Custom Domains**: External DNS validation with Hostpoint provider

## Development Commands

### 🎯 Development + 3 Deployment Environments (IaC-Compliant)
This project uses a clear separation between development and deployment:

**Development Environment:**
- **`local`** - Fast development with Docker Compose (no deployment needed)

**AWS Deployment Environments:**
- **`dev`** - AWS development deployment (CDK + Lambda + S3)
- **`staging`** - AWS staging deployment (CDK + Lambda + S3)
- **`production`** - AWS production deployment (CDK + Lambda + S3)

**Build Once, Deploy Everywhere**: The same production-optimized build artifact is deployed to all AWS environments, with environment-specific configuration injected at deployment time.

### Quick Start

**For Local Development** (recommended for daily work):
```bash
# Complete local development setup (< 15 minutes)
npm run setup:local       # Start Docker services + initialize environment
npm run start:local       # Start API & web apps from source code
./test-setup.sh          # Verify environment health
```

**For AWS Deployment** (testing in cloud environment):
```bash
# Deploy to AWS development environment
npm run build            # Create production-optimized build
npm run deploy:dev       # Deploy to AWS dev environment
```

### Build Commands (IaC-Compliant)
```bash
# Single build artifact for all environments
npm run build             # Build entire project (production-optimized)

# Component-specific builds
npm run build:packages    # Build shared packages only
npm run build:apps        # Build API and web applications only
npm run build:frontend    # Build web application only
npm run build:infrastructure # Build AWS CDK infrastructure only
```

**🎯 IaC Best Practice**: Building is environment-independent. The same build artifact is deployed to all environments (dev, staging, production) with environment-specific configuration injected at deployment/runtime.

**Runtime Configuration**: The web application loads environment-specific configuration from `/assets/config/config.json`, which is generated by the CDK during deployment. This ensures true portability - the same build can run in any environment.

### Deploy Commands (AWS Environments)
```bash
# Full stack deployment
npm run deploy:dev        # Build + deploy all stacks to dev environment
npm run deploy:staging    # Build + deploy all stacks to staging environment
npm run deploy:production # Build + deploy all stacks to production environment

# Safe deployment with health checks (recommended)
npm run deploy:safe:dev        # Safe deploy to dev with health checks
npm run deploy:safe:staging    # Safe deploy to staging with health checks
npm run deploy:safe:production # Safe deploy to production with health checks

# Frontend-only deployment (faster for UI changes)
npm run deploy:frontend:dev        # Deploy frontend to dev environment
npm run deploy:frontend:staging    # Deploy frontend to staging environment
npm run deploy:frontend:production # Deploy frontend to production environment

# Individual stack deployment (from infrastructure workspace)
cd infrastructure
npm run deploy:stack:infrastructure:dev # Deploy core infrastructure only
npm run deploy:stack:lambda:dev        # Deploy Lambda functions only
npm run deploy:stack:api:dev           # Deploy API Gateway only
npm run deploy:stack:certificate:dev   # Deploy SSL certificates (us-east-1)
npm run deploy:stack:web:dev           # Deploy web stack only

# Web-specific deployments (includes certificate + web stacks)
npm run deploy:web:dev     # Deploy web + certificate for dev
npm run deploy:web:staging # Deploy web + certificate for staging
npm run deploy:web:production # Deploy web + certificate for production

# Environment destruction with cleanup
npm run destroy:clean:dev     # Destroy dev + clean log groups
npm run destroy:clean:staging # Destroy staging + clean log groups
npm run destroy:clean:production # Destroy production + clean log groups

# Health checks and cleanup utilities
npm run health:check:dev          # Check dev environment health
npm run health:check:staging      # Check staging environment health
npm run health:check:production   # Check production environment health
npm run cleanup:logs:dev          # Clean orphaned log groups (dev)
npm run cleanup:logs:staging      # Clean orphaned log groups (staging)
npm run cleanup:logs:production   # Clean orphaned log groups (production)
```

**IaC Deployment Flow**:
1. `npm run build` - Creates single production-optimized artifact
2. `npm run deploy:dev` - Deploys same artifact to dev with dev config
3. `npm run deploy:staging` - Deploys same artifact to staging with staging config
4. `npm run deploy:production` - Deploys same artifact to production with production config

### Development vs Deployment Environments

**Local Development** (Fast Iteration):
- **Purpose**: Rapid development and debugging
- **Architecture**: Docker Compose + Direct Node.js execution
- **Services**: PostgreSQL, Redis, LocalStack (mocked AWS)
- **Commands**: `setup:local`, `start:local`
- **Benefits**: Instant reload, debugging, fast feedback loop
- **No deployment needed** - code runs directly from source

**AWS Deployment** (Production Testing):
- **Purpose**: Production-like testing and actual hosting
- **Architecture**: CDK + Lambda + S3 + CloudFront + Real AWS services
- **Services**: RDS, Cognito, SES, CloudFront, API Gateway
- **Commands**: `build`, `deploy:dev/staging/production`
- **Benefits**: Production parity, performance testing, real infrastructure
- **Deployment required** - infrastructure must be provisioned

### Local Development Commands
```bash
# Start applications
npm run start:local       # Start API & web apps in parallel
npm run start:local:api   # Start API server only
npm run start:local:web   # Start Angular app only

# Environment management
npm run env:local         # Start infrastructure services (Docker)
npm run env:local:setup   # Complete environment setup
npm run env:local:logs    # View service logs
npm run env:local:restart # Clean restart with complete setup
npm run env:local:clean   # Stop and remove all containers

# Setup commands
npm run setup:local       # Complete setup + start environment
```

### AWS/LocalStack Commands
```bash
npm run aws:local:start   # Start LocalStack with initialization
npm run aws:local:status  # Check LocalStack health
npm run aws:local:init    # Initialize LocalStack services
```

### Database Commands (Local Environment)
```bash
npm run db:setup:local    # Run migrations + load sample data
npm run db:migrate:local  # Run database migrations only
npm run db:seed:local     # Load comprehensive sample data only
npm run db:reset:local    # Reset database and reload (⚠️ Removes all data)
npm run db:validate:local # Validate sample data integrity
npm run db:status:local   # Check migration status
```

### Test Commands (Local Environment)
```bash
npm run test:local        # All tests in local environment
npm run test:integration:local # Integration tests against LocalStack
npm run test:e2e:local    # E2E tests in local environment
```

### Utility Commands
```bash
npm run clean             # Clean build artifacts and cache
npm run lint              # Run ESLint with auto-fix
npm run format            # Format code with Prettier
npm run type-check        # TypeScript type checking
npm run debug:api         # Start API in debug mode
```

## Frequently Asked Questions

### Why is there no `deploy:local` command?

**Answer**: Local development and AWS deployment use fundamentally different architectures:

- **Local development** runs code directly from source using Docker Compose for fast iteration
- **AWS deployment** uses CDK to provision Lambda functions, S3 buckets, and cloud infrastructure

**Local workflow** (no deployment):
```bash
npm run setup:local  # Start Docker services
npm run start:local  # Run from source code - instant changes
```

**AWS workflow** (requires deployment):
```bash
npm run build        # Create production artifacts
npm run deploy:dev   # Deploy to AWS infrastructure
```

This separation provides:
- ⚡ **Fast local development** - no build/deploy cycle needed
- 🏗️ **Production-like AWS testing** - real infrastructure deployment
- 🎯 **Clear separation** - development vs deployment concerns

If you need to test the deployment process locally, you can use `npm run build` to verify the build works, then deploy to the AWS dev environment for infrastructure testing.

## Architecture

### Local Development Stack
- **PostgreSQL** (port 5432) → AWS RDS in production
- **Redis** (port 6379) → AWS ElastiCache in production
- **LocalStack** (port 4566) → AWS Services in production
  - S3 (document storage)
  - Location Service (mocked)

### Technology Stack
- **Frontend**: Angular 17+ with TypeScript, Angular Material UI
- **Backend**: Node.js 20+ with TypeScript, Lambda functions
- **Database**: PostgreSQL 15 with PostGIS extension
- **Infrastructure**: AWS CDK 2.100+ in TypeScript
- **Development**: Docker Compose + LocalStack for AWS parity

### AWS CDK Architecture (5-Stack Design)

The infrastructure is organized into 5 independent CDK stacks for better separation of concerns and deployment flexibility:

```
1. InfrastructureStack (rtm-{env}-infrastructure)
   └── Core backend resources: VPC, RDS, Cognito, Location Service, SES, SNS
   └── Region: eu-central-1 (Swiss data residency)
   └── Exports: User Pool ID, Database endpoints, SNS Topic ARN

2. LambdaStack (rtm-{env}-lambda)
   └── All Lambda functions and their configurations
   └── Region: eu-central-1
   └── Depends on: InfrastructureStack (for VPC, database, etc.)
   └── Exports: ~30 Lambda function ARNs

3. ApiGatewayStack (rtm-{env}-api-gateway)
   └── REST API, routes, Lambda integrations, API custom domain
   └── Region: eu-central-1
   └── Depends on: LambdaStack (imports Lambda ARNs)
   └── Exports: API Gateway URL

4. CertificateStack (rtm-{env}-certificate) ⭐ NEW
   └── SSL certificates for CloudFront distribution
   └── Region: us-east-1 (CloudFront requirement)
   └── Cross-region references enabled
   └── Exports: Certificate ARN for CloudFront

5. WebStack (rtm-{env}-web)
   └── Frontend hosting: S3, CloudFront, web deployment
   └── Region: eu-central-1
   └── Depends on: ApiGatewayStack + InfrastructureStack + CertificateStack
   └── Uses cross-region certificate from us-east-1
   └── Exports: CloudFront domain URL
```

**Benefits of this architecture:**
- **Independent deployments**: Update frontend without touching backend
- **Cross-region compliance**: CloudFront certificates in us-east-1, data in eu-central-1
- **Clear dependencies**: No circular dependencies
- **Better CI/CD**: Each stack can have its own deployment pipeline
- **Cost optimization**: Destroy/recreate individual stacks as needed
- **DNS flexibility**: External DNS validation with any provider (Hostpoint, etc.)

### Key Service Configurations
```typescript
// Environment auto-detection
const isLocal = process.env.NODE_ENV === 'development';
const awsEndpoint = isLocal ? 'http://localhost:4566' : undefined;

// Local Database connection
DATABASE_URL: 'postgresql://nissim:devpass123@localhost:5432/travel_manager_dev'

// Production Database connection (AWS RDS)
DATABASE_URL: 'postgresql://rtm_admin:[SECRET]@rtm-dev-infrastructure-databaseb269d8bb-ynfofwwlfkkm.c18k2mga4rnh.eu-central-1.rds.amazonaws.com:5432/rtm_database'

// Cross-region SSL Certificate Configuration
// CloudFront requires certificates in us-east-1 region
const certificateStack = new CertificateStack(app, 'rtm-staging-certificate', {
  env: { region: 'us-east-1' }, // Required for CloudFront
  crossRegionReferences: true   // Enable cross-region access
});
```

## Development Guidelines

### Before Starting Development
1. **Always run environment health check**: `./test-setup.sh`
2. **Check service logs if issues arise**: `npm run env:local:logs`
3. **Use LocalStack for all AWS operations in development**
4. **Code should work identically in local and AWS deployment environments**

### 🔥 CRITICAL: API Response Pattern (MANDATORY)
**ALL API endpoints MUST use the centralized formatResponse pattern:**

**Backend (Lambda Handlers):**
```typescript
// ✅ ALWAYS DO THIS
import { formatResponse } from '../../middleware/response-formatter';

export const myHandler = async (event, context) => {
  // Success response
  return formatResponse(200, { users: [...] }, context.awsRequestId);

  // Error response
  return formatResponse(404, { code: 'NOT_FOUND', message: 'User not found' }, context.awsRequestId);
};

// ❌ NEVER manually build responses
return {
  statusCode: 200,
  body: JSON.stringify({ success: true, data: users })
};
```

**Frontend (Angular Services):**
```typescript
// ✅ ALWAYS expect data-wrapped responses
this.http.get<{data: UserType}>('/api/users').pipe(
  map(response => response.data)
)

// ❌ NEVER expect direct responses
this.http.get<UserType>('/api/users')
```

**Response Structure:**
- Success: `{ success: true, data: T, timestamp, requestId }`
- Error: `{ success: false, error: {...}, timestamp, requestId }`

### When Adding New Features
- **MANDATORY: Use formatResponse() for all API responses** - see pattern above
- **Use existing AWS service factory** in `apps/api/src/services/aws-factory.ts`
- **Add tests that run against LocalStack services**
- **Update environment configuration if new services needed**
- **Verify changes work in both local development and AWS deployment modes**

### Troubleshooting
- **Services not starting**: `npm run env:local:restart`
- **LocalStack issues**: `docker logs rtm-localstack`
- **Database issues**: `docker logs rtm-postgres`
- **Reset everything**: `npm run env:local:clean && npm run env:local && npm run aws:local:init`

## File Structure

```
RegularTravelManager/
├── apps/
│   ├── api/                 # Node.js Lambda functions
│   └── web/                 # Angular frontend
├── infrastructure/          # AWS CDK infrastructure code
│   ├── lib/
│   │   ├── infrastructure-stack.ts  # Core infrastructure (eu-central-1)
│   │   ├── lambda-stack.ts          # Lambda functions (eu-central-1)
│   │   ├── api-gateway-stack.ts     # API Gateway (eu-central-1)
│   │   ├── certificate-stack.ts     # SSL certificates (us-east-1) ⭐ NEW
│   │   ├── web-stack.ts             # Frontend hosting (eu-central-1)
│   │   └── config/environment-config.ts  # Environment configuration
│   └── package.json         # Deployment scripts
├── docs/
│   ├── architecture.md      # Complete architecture documentation
│   └── DEVELOPMENT_SETUP.md # Detailed setup guide
├── localstack/
│   └── init/               # LocalStack initialization scripts
├── docker-compose.yml      # Development infrastructure
└── test-setup.sh          # Environment verification script
```

## Development Authentication & Sample Data

### Comprehensive Sample Data
The development environment includes complete Swiss business data with production-matching test users:

**Admin Users (Full System Access):**
| User | Email | Name | Role | Employee ID | City |
|------|-------|------|------|-------------|------|
| **admin1** | admin1@company.ch | Hans Zimmermann | CEO/System Admin | ADM-0001 | Zürich |
| **admin2** | admin2@company.ch | Maria Weber | IT Administrator | ADM-0002 | Basel |

**Managers:**
| User | Email | Name | Role | Employee ID | City |
|------|-------|------|------|-------------|------|
| **manager1** | manager1@company.ch | Thomas Müller | Regional Manager | MGR-0001 | Zürich |
| **manager2** | manager2@company.ch | Sophie Dubois | Regional Manager | MGR-0002 | Genève |

**Employees:**
| User | Email | Name | Role | Employee ID | City |
|------|-------|------|------|-------------|------|
| **employee1** | employee1@company.ch | Anna Schneider | Software Developer | EMP-0001 | Bern |
| **employee2** | employee2@company.ch | Marco Rossi | Project Coordinator | EMP-0002 | Lugano |
| **employee3** | employee3@company.ch | Lisa Meier | Business Analyst | EMP-0003 | St. Gallen |
| **employee4** | employee4@company.ch | Pierre Martin | Marketing Specialist | EMP-0004 | Lausanne |
| **employee5** | employee5@company.ch | Julia Fischer | Technical Consultant | EMP-0005 | Basel |
| **employee6** | employee6@company.ch | Michael Keller | Sales Representative | EMP-0006 | Winterthur |

**Sample Data Includes:**
- 4 Business Projects with varying cost rates (0.65-0.80 CHF/km)
- 8 Subprojects across major Swiss cities with precise coordinates
- 5 Travel Requests covering complete lifecycle (pending, approved, rejected, withdrawn)
- Complete audit trails for status changes and address history
- Realistic Swiss business scenarios and geographic coverage

**User Passwords (AWS Cognito):**
- **Admin Users**: `AdminPass123!Test`
- **Manager Users**: `ManagerPass123!`
- **Employee Users**: `EmployeePass123!`

### User Access

**For Local Development (Mock Auth):**
In the browser console (F12), run:
```javascript
// Admin Users (Full system access)
localStorage.setItem('mockUser', 'admin1');     // Hans Zimmermann (CEO)
localStorage.setItem('mockUser', 'admin2');     // Maria Weber (IT Admin)

// Managers  
localStorage.setItem('mockUser', 'manager1');   // Thomas Müller
localStorage.setItem('mockUser', 'manager2');   // Sophie Dubois

// Employees (default: employee1)
localStorage.setItem('mockUser', 'employee1');  // Anna Schneider (Developer)
localStorage.setItem('mockUser', 'employee2');  // Marco Rossi (PM)
localStorage.setItem('mockUser', 'employee3');  // Lisa Meier (BA)
localStorage.setItem('mockUser', 'employee4');  // Pierre Martin (Marketing)
localStorage.setItem('mockUser', 'employee5');  // Julia Fischer (Consultant)
localStorage.setItem('mockUser', 'employee6');  // Michael Keller (Sales)

window.location.reload();
```

**Mock User ID Mapping (UUID format for dev environment):**
- admin1@company.ch → `11111111-1111-1111-1111-111111111111`
- admin2@company.ch → `22222222-2222-2222-2222-222222222222`
- manager1@company.ch → `33333333-3333-3333-3333-333333333333`
- manager2@company.ch → `44444444-4444-4444-4444-444444444444`
- employee1@company.ch → `55555555-5555-5555-5555-555555555555`
- employee2@company.ch → `66666666-6666-6666-6666-666666666666`
- employee3@company.ch → `77777777-7777-7777-7777-777777777777`
- employee4@company.ch → `88888888-8888-8888-8888-888888888888`
- employee5@company.ch → `99999999-9999-9999-9999-999999999999`
- employee6@company.ch → `aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa`

**For Production/AWS Environment:**
Use the email addresses and passwords listed above to log in directly via the Cognito authentication.

### Authentication Architecture
- **Local Development**: Mock authentication with production user data
- **Production/AWS**: AWS Cognito with real user management (deployed and working)
- **LocalStack**: Cognito is Pro feature - uses mock authentication in local development
- **User data**: Consistent across frontend auth service and backend API
- **Test Users**: 10 fully configured users with proper permissions and sample data

## Notes

- **Environment parity**: Local development provides 95% AWS production parity
- **Sample Data**: Comprehensive Swiss business data with admin, manager, and employee users
- **Admin Interface**: Full user and project management capabilities
- **Geographic Coverage**: All major Swiss cities with accurate coordinates and realistic business scenarios
- **Cost savings**: ~€200/month per developer using LocalStack vs real AWS
- **Setup time**: < 15 minutes for new developers
- **Offline development**: Full development capability without internet
- **Documentation**: See DEVELOPMENT_SETUP.md for detailed troubleshooting
- **Data Validation**: Built-in integrity checks for geographic calculations, business constraints, and audit trails

## Important: Essential Development Files

**⚠️ NEVER REMOVE these directories - they are essential development infrastructure:**

- **`.bmad-core/`** - BMAD agent system files for proper development workflow
- **`.claude/commands/BMad/`** - Claude commands directory for development assistance
- **`web-bundles/`** - Essential files for correct development practices

These are **development tooling files**, not project artifacts. Removing them will break the development workflow.

## Certificate & DNS Management

### SSL Certificate Process
1. **Certificate Creation**: Created in us-east-1 region for CloudFront compatibility
2. **DNS Validation**: External DNS provider (Hostpoint) adds CNAME validation records
3. **Cross-Region Access**: CDK's experimental `crossRegionReferences: true` enables access
4. **Domain Configuration**:
   - Frontend: `rtfm-staging.buchs.be` (corrected from rtm-staging)
   - API: `api-staging.buchs.be`

### Deployment Order
```bash
# Required deployment sequence for cross-region setup
cd infrastructure
npm run bootstrap:all-regions        # Bootstrap both eu-central-1 and us-east-1
npm run deploy:certificate:staging   # Deploy certificates to us-east-1
npm run deploy:frontend:staging      # Deploy frontend with certificate reference
```

### DNS Configuration (Manual)
After deployment, configure these CNAME records in your DNS provider:
```
rtfm-staging  CNAME  d23i41oue7n59b.cloudfront.net  # Frontend (will be updated)
api-staging   CNAME  xyz.cloudfront.net             # API Gateway custom domain
```

- always update the readme.md when you update package.json, aws urls or other readme relevant files
- when you develop software and update existing software, never keep old code or functions for backward compatibility
- we are working on enterprise software. never use workarounds. always document new pattterns or factory usage. consistently use existing implementation pattterns, never add TODO.
- when deploying to aws, set long enough timeouts
- use longer timeouts