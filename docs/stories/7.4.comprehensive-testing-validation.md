# Story 7.4: comprehensive-testing-validation

## Status
Accepted

## Story
**As a** quality assurance engineer,
I want **comprehensive multilingual testing coverage**,
so that **language switching works reliably across all user scenarios**.

## Acceptance Criteria
1. **Unit Testing**: Complete test coverage for translation services and components
2. **Integration Testing**: End-to-end language switching across all major user workflows
3. **Translation Validation**: Automated validation that all UI elements have translation keys
4. **Performance Testing**: Translation loading performance and caching effectiveness validation
5. **Accessibility Testing**: WCAG 2.1 AA compliance across all supported languages
6. **Cross-Browser Testing**: Language switching functionality across major browsers
7. **Error Scenario Testing**: Translation failure handling and fallback behavior validation

## Tasks / Subtasks

- [ ] Task 1: Implement Unit Testing for Translation Services (AC: 1)
  - [ ] Write unit tests for TranslationService (language switching, caching, parameter interpolation)
  - [ ] Write unit tests for TranslationLoader (HTTP loading, error handling, cache management)
  - [ ] Write unit tests for LanguageService (localStorage persistence, browser detection)
  - [ ] Write unit tests for MasterDataTranslationService (API integration, cache behavior)
  - [ ] Write unit tests for TranslatePipe (transformation, async behavior, parameter handling)

- [ ] Task 2: Implement Component Testing for Translation UI (AC: 1)
  - [ ] Write component tests for LanguageSwitcherComponent (interaction, visual feedback)
  - [ ] Test translation pipe integration in component templates
  - [ ] Test reactive translation observables in component logic
  - [ ] Test language change propagation across component hierarchy
  - [ ] Achieve minimum 90% code coverage for translation components

- [ ] Task 3: Create Integration Tests for HTTP Interceptor (AC: 1)
  - [ ] Test MasterDataTranslationInterceptor field mapping and transformation
  - [ ] Test configuration-driven translation per API endpoint
  - [ ] Test interceptor error handling and fallback behavior
  - [ ] Test cache integration between interceptor and translation service
  - [ ] Validate request/response transformation accuracy

- [ ] Task 4: Implement Backend Lambda Function Testing (AC: 1)
  - [ ] Write unit tests for translate-master-data Lambda handler
  - [ ] Test AWS Translate client integration and error scenarios
  - [ ] Test PostgreSQL translation cache functionality
  - [ ] Test performance optimization and cost tracking
  - [ ] Mock AWS services for unit testing environment

- [ ] Task 5: Create End-to-End Language Switching Tests (AC: 2)
  - [ ] Test complete employee workflow with language switching (German, French, Italian, English)
  - [ ] Test manager approval workflow across all languages
  - [ ] Test admin user management with multilingual interface
  - [ ] Test travel request form submission with translated validation messages
  - [ ] Test dashboard navigation and data display in all languages

- [ ] Task 6: Implement Translation Key Validation (AC: 3)
  - [ ] Create automated script to scan components for missing translation keys
  - [ ] Validate translation file completeness across all languages (de.json, fr.json, it.json, en.json)
  - [ ] Check for unused translation keys and cleanup
  - [ ] Validate translation key naming convention adherence
  - [ ] Generate translation coverage report

- [ ] Task 7: Performance Testing Implementation (AC: 4)
  - [ ] Test initial translation file loading performance (<2s for all languages)
  - [ ] Validate cache effectiveness and hit rates (>80% cache hit rate target)
  - [ ] Test memory usage during language switching (<10MB increase per switch)
  - [ ] Benchmark AWS Translate API response times and cost optimization
  - [ ] Test concurrent user language switching performance

- [ ] Task 8: Accessibility Testing Across Languages (AC: 5)
  - [ ] WCAG 2.1 AA compliance testing for all supported languages
  - [ ] Screen reader compatibility testing (VoiceOver, NVDA, JAWS)
  - [ ] Keyboard navigation testing with translated interfaces
  - [ ] Color contrast validation for translated content
  - [ ] Language direction and text flow validation

- [ ] Task 9: Cross-Browser Testing Implementation (AC: 6)
  - [ ] Test language switching in Chrome, Firefox, Safari, Edge
  - [ ] Validate translation file loading across different browsers
  - [ ] Test localStorage persistence across browser sessions
  - [ ] Test responsive design with translated content
  - [ ] Validate browser language detection accuracy

- [ ] Task 10: Error Scenario and Fallback Testing (AC: 7)
  - [ ] Test AWS Translate service failure scenarios
  - [ ] Test network connectivity issues during translation loading
  - [ ] Test fallback to original text when translation fails
  - [ ] Test partial translation file loading scenarios
  - [ ] Test invalid language code handling

- [ ] Task 11: Performance Monitoring and Reporting
  - [ ] Set up continuous performance monitoring for translation services
  - [ ] Create automated translation quality reports
  - [ ] Implement translation cost monitoring and alerting
  - [ ] Set up translation error rate monitoring
  - [ ] Create multilingual testing dashboard

## Infrastructure Impact Assessment ⚠️ REQUIRED

### Frontend Changes
- [x] **New Components/Pages** - Testing components required:
  - Test utilities for translation service mocking
  - Test harnesses for language switching scenarios
- [x] **State Management** - Testing state management:
  - Mock BehaviorSubjects for translation service testing
  - Test state transitions during language switching
- [ ] **Routing** - No new routes required for testing
- [x] **API Integration** - Testing API integration:
  - Mock HTTP clients for translation service testing
  - Test translation interceptor behavior

### Backend Changes
- [x] **New API Endpoints** - Testing endpoints:
  - Health check endpoints for translation service validation
- [x] **Lambda Functions** - Testing Lambda functions:
  - Test harnesses for translate-master-data function
  - Mock AWS Translate client for unit testing
- [x] **Database Changes** - Testing database:
  - Test data setup for translation cache validation
  - Database cleanup procedures for testing
- [x] **Authentication** - Testing authentication:
  - Mock Cognito authentication for translation endpoint testing

### Infrastructure Changes (AWS CDK)
- [x] **API Gateway** - Testing configuration:
  - Test environment configuration for translation endpoints
- [x] **Lambda Configuration** - Testing Lambda deployment:
  - Test Lambda function configuration and permissions
- [x] **Database** - Testing database setup:
  - Test database migration and schema validation
- [x] **Environment Variables** - Testing configuration:
  - Test environment-specific translation service configuration
- [x] **IAM Permissions** - Testing permissions:
  - Validate AWS Translate permissions in test environment
- [x] **Other AWS Services** - Testing AWS services:
  - LocalStack configuration for AWS Translate testing

### Development Environment
- [x] **Docker Services** - Testing services:
  - LocalStack with AWS Translate mocking for testing
- [x] **LocalStack** - Testing AWS services:
  - Configure LocalStack Pro features for AWS Translate testing
- [x] **Sample Data** - Testing data:
  - Multilingual test data across all supported languages
- [x] **Environment Setup** - Testing environment:
  - Playwright browser setup for cross-browser testing
  - Accessibility testing tools integration

## Dev Notes

### Technical Design Notes

**Comprehensive Testing Strategy**:
This story implements complete testing coverage for the dual-layer multilingual translation system. Testing covers both JSON-based static UI translation (Layer 1) and AWS Translate dynamic master data translation (Layer 2) with comprehensive validation of performance, accessibility, and error scenarios.

**Frontend Testing Architecture** [Source: docs/architecture/07-development-standards.md]:
```typescript
// Translation Service Testing Pattern
describe('TranslationService', () => {
  let service: TranslationService;
  let mockLoader: jest.Mocked<TranslationLoader>;
  let mockLanguageService: jest.Mocked<LanguageService>;

  beforeEach(() => {
    const loaderSpy = jest.createMockFromModule<TranslationLoader>('./translation-loader.service');
    const languageSpy = jest.createMockFromModule<LanguageService>('./language.service');

    TestBed.configureTestingModule({
      providers: [
        TranslationService,
        { provide: TranslationLoader, useValue: loaderSpy },
        { provide: LanguageService, useValue: languageSpy }
      ]
    });

    service = TestBed.inject(TranslationService);
    mockLoader = TestBed.inject(TranslationLoader) as jest.Mocked<TranslationLoader>;
    mockLanguageService = TestBed.inject(LanguageService) as jest.Mocked<LanguageService>;
  });

  describe('translate', () => {
    it('should handle parameter interpolation correctly', async () => {
      // Arrange
      const translationKey = 'employee.dashboard.welcome';
      const params = { name: 'Anna Schneider' };
      const expectedTranslation = 'Welcome back, Anna Schneider!';

      mockLoader.loadLanguage.mockResolvedValue({
        'employee.dashboard.welcome': 'Welcome back, {{name}}!'
      });

      // Act
      const result = await service.translate(translationKey, params).toPromise();

      // Assert
      expect(result).toBe(expectedTranslation);
    });
  });
});
```

**Component Testing with Translation Integration** [Source: docs/architecture/07-development-standards.md]:
```typescript
// Language Switcher Component Testing
describe('LanguageSwitcherComponent', () => {
  let component: LanguageSwitcherComponent;
  let fixture: ComponentFixture<LanguageSwitcherComponent>;
  let mockTranslationService: jasmine.SpyObj<TranslationService>;

  beforeEach(() => {
    const spy = jasmine.createSpyObj('TranslationService', ['setLanguage', 'getCurrentLanguage']);

    TestBed.configureTestingModule({
      declarations: [LanguageSwitcherComponent],
      imports: [MatSelectModule, MatIconModule, NoopAnimationsModule],
      providers: [{ provide: TranslationService, useValue: spy }]
    });

    fixture = TestBed.createComponent(LanguageSwitcherComponent);
    component = fixture.componentInstance;
    mockTranslationService = TestBed.inject(TranslationService) as jasmine.SpyObj<TranslationService>;
  });

  it('should switch language and show visual feedback', fakeAsync(() => {
    // Arrange
    const newLanguage = 'de';

    // Act
    component.onLanguageChange(newLanguage);
    tick(300); // Wait for visual feedback timeout

    // Assert
    expect(mockTranslationService.setLanguage).toHaveBeenCalledWith(newLanguage);
    expect(component.currentLanguage$.value).toBe(newLanguage);
  }));
});
```

**Backend Lambda Function Testing** [Source: docs/architecture/07-development-standards.md]:
```typescript
// AWS Translate Lambda Handler Testing
describe('translateMasterDataHandler', () => {
  let mockTranslateClient: jest.Mocked<TranslateClient>;
  let mockDb: jest.Mocked<DatabaseClient>;

  beforeEach(() => {
    mockTranslateClient = createMockTranslateClient();
    mockDb = createMockDatabase();

    // Mock AWS SDK
    jest.mock('@aws-sdk/client-translate', () => ({
      TranslateClient: jest.fn(() => mockTranslateClient),
      TranslateTextCommand: jest.fn()
    }));
  });

  it('should translate text and cache result', async () => {
    // Arrange
    const event = createMockAPIGatewayEvent({
      body: JSON.stringify({
        text: 'Zurich Project',
        targetLanguage: 'de',
        context: 'project'
      })
    });

    const expectedTranslation = 'Projekt Zürich';
    mockTranslateClient.send.mockResolvedValue({
      TranslatedText: expectedTranslation
    });

    // Act
    const result = await translateMasterDataHandler(event, mockContext);

    // Assert
    expect(result.statusCode).toBe(200);
    const body = JSON.parse(result.body);
    expect(body.data.translatedText).toBe(expectedTranslation);
    expect(mockDb.query).toHaveBeenCalledWith(
      expect.stringContaining('INSERT INTO master_data_translations')
    );
  });
});
```

**E2E Testing with Playwright** [Source: docs/architecture/07-development-standards.md]:
```typescript
// Complete Multilingual User Workflow Testing
test.describe('Multilingual Travel Request Workflow', () => {
  test('complete employee workflow with language switching', async ({ page }) => {
    // Login and switch to German
    await page.goto('/login');
    await page.fill('[data-testid=email]', 'employee1@company.ch');
    await page.fill('[data-testid=password]', 'EmployeePass123!');
    await page.click('[data-testid=login-button]');

    // Switch to German
    await page.click('[data-testid=language-switcher]');
    await page.click('[data-testid=language-option-de]');

    // Verify German interface
    await expect(page.locator('[data-testid=dashboard-title]')).toContainText('Reiseanträge Dashboard');

    // Create new request with German interface
    await page.click('[data-testid=new-request-button]');
    await expect(page.locator('[data-testid=form-title]')).toContainText('Neuer Reiseantrag');

    // Verify project names are translated to German
    await page.selectOption('[data-testid=project-select]', { index: 1 });
    const selectedOption = await page.locator('[data-testid=project-select] option:checked').textContent();
    expect(selectedOption).toMatch(/Projekt/); // German "Projekt" instead of "Project"

    // Fill form and submit
    await page.fill('[data-testid=justification]', 'Wöchentliche Teammeetings und Kundenpräsentationen');
    await page.click('[data-testid=submit-button]');

    // Verify German success message
    await expect(page.locator('[data-testid=success-message]')).toContainText('erfolgreich eingereicht');
  });
});
```

**Translation Key Validation Script**:
```typescript
// Automated Translation Key Validation
export class TranslationKeyValidator {
  async validateTranslationCompleteness(): Promise<ValidationReport> {
    const report: ValidationReport = {
      missingKeys: [],
      unusedKeys: [],
      inconsistentKeys: [],
      coveragePercentage: 0
    };

    // Scan all components for translation keys
    const usedKeys = await this.scanComponentsForTranslationKeys();

    // Load all translation files
    const translationFiles = ['de.json', 'fr.json', 'it.json', 'en.json'];
    const translations = await Promise.all(
      translationFiles.map(file => this.loadTranslationFile(file))
    );

    // Validate completeness
    for (const key of usedKeys) {
      for (const [index, translation] of translations.entries()) {
        if (!this.hasTranslationKey(translation, key)) {
          report.missingKeys.push({
            key,
            language: translationFiles[index],
            component: this.findKeyUsage(key)
          });
        }
      }
    }

    // Calculate coverage
    report.coveragePercentage =
      ((usedKeys.length - report.missingKeys.length) / usedKeys.length) * 100;

    return report;
  }

  private async scanComponentsForTranslationKeys(): Promise<string[]> {
    // Scan TypeScript and HTML files for translation key usage
    const files = await glob('apps/web/src/**/*.{ts,html}');
    const keys = new Set<string>();

    for (const file of files) {
      const content = await fs.readFile(file, 'utf-8');

      // Extract keys from translate pipe usage: {{ 'key' | translate }}
      const pipeMatches = content.match(/'([^']+)'\s*\|\s*translate/g) || [];
      pipeMatches.forEach(match => {
        const key = match.match(/'([^']+)'/)?.[1];
        if (key) keys.add(key);
      });

      // Extract keys from service usage: this.translationService.translate('key')
      const serviceMatches = content.match(/translate\(['"]([^'"]+)['"]\)/g) || [];
      serviceMatches.forEach(match => {
        const key = match.match(/['"]([^'"]+)['"]/)?.[1];
        if (key) keys.add(key);
      });
    }

    return Array.from(keys);
  }
}
```

**Performance Testing Implementation**:
```typescript
// Translation Performance Testing
export class TranslationPerformanceTester {
  async testTranslationLoadingPerformance(): Promise<PerformanceMetrics> {
    const metrics: PerformanceMetrics = {
      initialLoadTime: 0,
      cacheHitRate: 0,
      memoryUsage: 0,
      languageSwitchTime: []
    };

    // Test initial loading
    const startTime = performance.now();
    await this.translationService.loadLanguage('en');
    metrics.initialLoadTime = performance.now() - startTime;

    // Test cache effectiveness
    const cacheTests = 100;
    let cacheHits = 0;

    for (let i = 0; i < cacheTests; i++) {
      const cached = await this.translationService.instant('common.buttons.save');
      if (cached !== 'common.buttons.save') cacheHits++; // Not fallback = cache hit
    }
    metrics.cacheHitRate = (cacheHits / cacheTests) * 100;

    // Test language switching performance
    for (const language of ['de', 'fr', 'it']) {
      const switchStart = performance.now();
      await this.translationService.setLanguage(language);
      metrics.languageSwitchTime.push(performance.now() - switchStart);
    }

    // Test memory usage
    const initialMemory = (performance as any).memory?.usedJSHeapSize || 0;
    await this.loadAllLanguages();
    const finalMemory = (performance as any).memory?.usedJSHeapSize || 0;
    metrics.memoryUsage = finalMemory - initialMemory;

    return metrics;
  }
}
```

### Testing Standards

**Testing Framework and Patterns** [Source: docs/architecture/07-development-standards.md]:
- **Frontend Testing**: Jest + Angular Testing Utilities, Playwright for E2E
- **Backend Testing**: Jest with AWS SDK mocking, Supertest for integration
- **Translation Testing**: Custom validation scripts and performance benchmarks

**Testing Requirements for Multilingual System**:
- **Unit Test Coverage**: Minimum 90% for all translation services and components
- **Integration Testing**: Complete workflows tested in all 4 languages
- **Performance Benchmarks**: <2s initial load, >80% cache hit rate, <10MB memory increase
- **Accessibility Testing**: WCAG 2.1 AA compliance across all languages
- **Cross-Browser Testing**: Chrome, Firefox, Safari, Edge support validation

**Testing Patterns**:
- **Service Mocking**: Mock AWS Translate client, HTTP clients, localStorage
- **Component Testing**: TestBed configuration with translation service mocks
- **E2E Testing**: Playwright with data-testid selectors and multilingual workflows
- **Performance Testing**: Custom metrics collection and benchmarking
- **Validation Scripts**: Automated translation key completeness checking

## Definition of Done Checklist

### Development Complete
- [ ] All acceptance criteria implemented
- [ ] Unit tests written and passing (90% coverage minimum)
- [ ] Integration tests cover multilingual functionality
- [ ] Code follows project conventions
- [ ] TypeScript types properly defined for all test utilities

### Infrastructure Complete ⚠️ CRITICAL
- [ ] Test environments configured (LocalStack with AWS Translate)
- [ ] Playwright browser testing environment set up
- [ ] Translation validation scripts integrated into CI/CD
- [ ] Performance monitoring configured for translation services
- [ ] Accessibility testing tools integrated
- [ ] Cross-browser testing infrastructure validated
- [ ] Test data setup across all supported languages

### Review Ready
- [ ] PR created with comprehensive testing documentation
- [ ] Code review completed for all testing implementations
- [ ] QA validation of testing coverage and effectiveness
- [ ] Documentation updated with testing procedures
- [ ] Testing guidelines added to development standards

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-25 | 1.0 | Initial story creation with comprehensive testing strategy | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
<!-- Populated by development agent -->

### Debug Log References
<!-- Populated by development agent -->

### Completion Notes List
<!-- Populated by development agent -->

### File List
<!-- Populated by development agent -->

## QA Results
<!-- Results from QA Agent review -->