# RegularTravelManager Internationalization (i18n) Architecture

**Document Version:** 1.0
**Date:** 2025-09-23
**Author:** Winston (Architect)
**Target:** Swiss Market Multilingual Support

---

## 1. Executive Summary

This document outlines the comprehensive internationalization strategy for RegularTravelManager, designed specifically for the Swiss market. The solution implements a hybrid translation approach combining Angular i18n for static UI elements with AWS Translate for dynamic masterdata content, supporting German (DE), French (FR), Italian (IT), and English (EN) languages.

### Key Features
- **Hybrid Translation Architecture**: Static UI (compile-time) + Dynamic content (runtime)
- **Swiss Market Focus**: Four official languages with intelligent fallback strategies
- **Original Text Tooltips**: Always accessible original content with translation confidence indicators
- **Performance Optimized**: Translation caching, lazy loading, and build-time optimization
- **User Experience**: Seamless language switching with persistent preferences

---

## 2. Architecture Overview

### 2.1 Multilingual Strategy

**ðŸŽ¯ Swiss Market Requirements:**
- **DE** (German) - Primary business language
- **FR** (French) - Western Switzerland
- **IT** (Italian) - Southern Switzerland
- **EN** (English) - International businesses

**Architecture Philosophy:**
- **Static UI Text**: Angular i18n with compile-time optimization
- **Dynamic Masterdata**: Runtime translation with original text tooltips
- **User Preference Persistence**: Database + LocalStorage sync
- **Fallback Strategy**: EN â†’ DE â†’ Original text

### 2.2 Translation Layers Architecture

```typescript
// Translation Layer Hierarchy
1. Static UI Translation (Angular i18n)
   â”œâ”€â”€ Compile-time translation bundles
   â”œâ”€â”€ Route-based lazy loading per locale
   â””â”€â”€ Build optimization for each language

2. Dynamic Content Translation (Runtime)
   â”œâ”€â”€ Project/Subproject names (Auto-translation)
   â”œâ”€â”€ Status messages (Contextual)
   â””â”€â”€ Validation errors (Real-time)

3. User Context Management
   â”œâ”€â”€ Language preference storage
   â”œâ”€â”€ Locale-specific formatting
   â””â”€â”€ Regional business rules
```

---

## 3. Technical Implementation

### 3.1 Frontend Translation Architecture

**Enhanced Language Service:**

```typescript
// apps/web/src/app/core/services/language.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { HttpClient } from '@angular/common/http';

@Injectable({ providedIn: 'root' })
export class LanguageService {
  // Static supported languages for Swiss market
  private readonly SUPPORTED_LANGUAGES = ['de', 'fr', 'it', 'en'] as const;
  private readonly DEFAULT_LANGUAGE = 'en';
  private readonly STORAGE_KEY = 'rtm_user_language';

  private currentLanguageSubject = new BehaviorSubject<SupportedLanguage>('en');
  private translationsCache = new Map<string, TranslationCache>();

  // Phase 1: User preference with persistence
  public currentLanguage$ = this.currentLanguageSubject.asObservable();

  constructor(
    private translationService: TranslationApiService,
    private userPreferenceService: UserPreferenceService,
    private configService: ConfigService,
    private http: HttpClient
  ) {
    this.initializeLanguage();
  }

  // Initialize language from user profile or browser
  private initializeLanguage(): void {
    // Priority: User stored preference â†’ Browser language â†’ Default (EN)
    const storedLang = localStorage.getItem(this.STORAGE_KEY) as SupportedLanguage;
    const browserLang = this.getBrowserLanguage();
    const initialLang = storedLang || browserLang || this.DEFAULT_LANGUAGE;

    this.setLanguage(initialLang);
  }

  private getBrowserLanguage(): SupportedLanguage {
    const browserLang = navigator.language.split('-')[0] as SupportedLanguage;
    return this.SUPPORTED_LANGUAGES.includes(browserLang) ? browserLang : this.DEFAULT_LANGUAGE;
  }

  setLanguage(language: SupportedLanguage): void {
    if (this.SUPPORTED_LANGUAGES.includes(language)) {
      this.currentLanguageSubject.next(language);
      localStorage.setItem(this.STORAGE_KEY, language);

      // Persist to user profile if logged in
      this.persistUserLanguagePreference(language);
    }
  }

  private async persistUserLanguagePreference(language: SupportedLanguage): Promise<void> {
    try {
      await this.http.put('/api/user/language-preference', { language }).toPromise();
    } catch (error) {
      console.warn('Failed to persist language preference:', error);
    }
  }

  // Dynamic content translation with caching
  async translateContent(
    originalText: string,
    targetLang: SupportedLanguage,
    context: 'project' | 'subproject' | 'status' = 'project'
  ): Promise<TranslatedContent> {
    const cacheKey = `${originalText}:${targetLang}:${context}`;

    if (this.translationsCache.has(cacheKey)) {
      return this.translationsCache.get(cacheKey)!.content;
    }

    try {
      const translation = await this.translationService.translate({
        text: originalText,
        targetLanguage: targetLang,
        context,
        sourceLanguage: 'auto'
      });

      const result: TranslatedContent = {
        translatedText: translation.text,
        originalText,
        confidence: translation.confidence,
        language: targetLang
      };

      // Cache successful translations
      this.translationsCache.set(cacheKey, {
        content: result,
        timestamp: Date.now(),
        ttl: 24 * 60 * 60 * 1000 // 24 hours
      });

      return result;
    } catch (error) {
      // Fallback to original text
      return {
        translatedText: originalText,
        originalText,
        confidence: 0,
        language: targetLang,
        fallback: true
      };
    }
  }

  getCurrentLanguage(): SupportedLanguage {
    return this.currentLanguageSubject.value;
  }

  getSupportedLanguages(): readonly SupportedLanguage[] {
    return this.SUPPORTED_LANGUAGES;
  }
}

// Translation Models
interface TranslatedContent {
  translatedText: string;
  originalText: string;
  confidence: number;
  language: SupportedLanguage;
  fallback?: boolean;
}

interface TranslationCache {
  content: TranslatedContent;
  timestamp: number;
  ttl: number;
}

type SupportedLanguage = 'de' | 'fr' | 'it' | 'en';
```

### 3.2 Smart Translation Directive

**Dynamic Content Translation with Tooltips:**

```typescript
// apps/web/src/app/shared/directives/translate.directive.ts
import { Directive, ElementRef, Input, OnInit, OnDestroy, AfterViewInit, Renderer2, Injector } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, distinctUntilChanged, debounceTime } from 'rxjs/operators';
import { MatTooltip } from '@angular/material/tooltip';

@Directive({
  selector: '[appTranslate]',
  standalone: true
})
export class TranslateDirective implements OnInit, OnDestroy, AfterViewInit {
  @Input('appTranslate') originalText!: string;
  @Input() translationContext: 'project' | 'subproject' | 'status' = 'project';
  @Input() showTooltip = true;
  @Input() showConfidence = false;
  @Input() fallbackToOriginal = true;

  private destroy$ = new Subject<void>();
  private currentLanguage: SupportedLanguage = 'en';
  private translationResult: TranslationResponse | null = null;

  constructor(
    private elementRef: ElementRef,
    private languageService: LanguageService,
    private translationService: TranslationApiService,
    private renderer: Renderer2,
    private injector: Injector
  ) {}

  ngOnInit(): void {
    this.languageService.currentLanguage$
      .pipe(
        takeUntil(this.destroy$),
        distinctUntilChanged(),
        debounceTime(100) // Prevent rapid language switching
      )
      .subscribe(language => {
        this.currentLanguage = language;
        this.updateTranslation();
      });
  }

  ngAfterViewInit(): void {
    // Initial translation after view is ready
    this.updateTranslation();
  }

  private async updateTranslation(): Promise<void> {
    if (!this.originalText?.trim()) return;

    // Skip translation if current language matches original (assume German original)
    if (this.currentLanguage === 'de' && this.isGermanText(this.originalText)) {
      this.setElementText(this.originalText);
      return;
    }

    try {
      this.addLoadingState();

      const translation = await this.translationService.translateContent({
        text: this.originalText,
        targetLanguage: this.currentLanguage,
        context: this.translationContext
      }).toPromise();

      this.translationResult = translation;
      this.setElementText(translation.translatedText);
      this.setupTooltip(translation);
      this.addConfidenceIndicator(translation);

    } catch (error) {
      console.warn('Translation failed for:', this.originalText, error);

      if (this.fallbackToOriginal) {
        this.setElementText(this.originalText);
        this.setupFallbackTooltip();
      }
    } finally {
      this.removeLoadingState();
    }
  }

  private isGermanText(text: string): boolean {
    // Simple heuristic to detect German text
    const germanIndicators = ['ÃŸ', 'Ã¤', 'Ã¶', 'Ã¼', 'Ã„', 'Ã–', 'Ãœ'];
    return germanIndicators.some(char => text.includes(char));
  }

  private setElementText(text: string): void {
    this.renderer.setProperty(this.elementRef.nativeElement, 'textContent', text);
  }

  private setupTooltip(translation: TranslationResponse): void {
    if (!this.showTooltip) return;

    const confidence = Math.round(translation.confidence * 100);
    const tooltipText = $localize`:@@translation.tooltip:Original: ${translation.originalText}\nTranslation confidence: ${confidence}%\nLanguage: ${translation.sourceLanguage} â†’ ${translation.targetLanguage}`;

    this.renderer.setAttribute(this.elementRef.nativeElement, 'title', tooltipText);
    this.renderer.addClass(this.elementRef.nativeElement, 'translated-content');

    // Add Material Tooltip if available
    try {
      const tooltip = this.injector.get(MatTooltip, null);
      if (tooltip) {
        tooltip.message = tooltipText;
        tooltip.position = 'above';
      }
    } catch {
      // MatTooltip not available, use native title
    }
  }

  private setupFallbackTooltip(): void {
    if (!this.showTooltip) return;

    const tooltipText = $localize`:@@translation.fallback:Translation unavailable. Showing original text.`;
    this.renderer.setAttribute(this.elementRef.nativeElement, 'title', tooltipText);
    this.renderer.addClass(this.elementRef.nativeElement, 'translation-fallback');
  }

  private addConfidenceIndicator(translation: TranslationResponse): void {
    if (!this.showConfidence) return;

    // Visual confidence indicator
    if (translation.confidence < 0.7) {
      this.renderer.addClass(this.elementRef.nativeElement, 'low-confidence-translation');
    } else if (translation.confidence < 0.9) {
      this.renderer.addClass(this.elementRef.nativeElement, 'medium-confidence-translation');
    } else {
      this.renderer.addClass(this.elementRef.nativeElement, 'high-confidence-translation');
    }
  }

  private addLoadingState(): void {
    this.renderer.addClass(this.elementRef.nativeElement, 'translation-loading');
  }

  private removeLoadingState(): void {
    this.renderer.removeClass(this.elementRef.nativeElement, 'translation-loading');
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

### 3.3 CSS Styles for Translation States

```css
/* apps/web/src/styles/translation.scss */
.translated-content {
  border-bottom: 1px dotted #666;
  cursor: help;
  transition: all 0.2s ease;
}

.translated-content:hover {
  background-color: rgba(0, 123, 255, 0.1);
}

.translation-fallback {
  font-style: italic;
  opacity: 0.8;
  background-color: rgba(255, 193, 7, 0.1);
}

.low-confidence-translation {
  background-color: rgba(255, 193, 7, 0.1);
  border-left: 3px solid #ffc107;
  padding-left: 4px;
}

.medium-confidence-translation {
  background-color: rgba(255, 152, 0, 0.1);
  border-left: 3px solid #ff9800;
  padding-left: 4px;
}

.high-confidence-translation {
  background-color: rgba(76, 175, 80, 0.1);
  border-left: 3px solid #4caf50;
  padding-left: 4px;
}

.translation-loading {
  opacity: 0.6;
  background: linear-gradient(90deg, transparent, rgba(0,0,0,0.1), transparent);
  background-size: 200px 100%;
  animation: translationLoading 1s ease-in-out infinite;
}

@keyframes translationLoading {
  0% { background-position: -200px 0; }
  100% { background-position: calc(200px + 100%) 0; }
}

/* Language-specific styling */
.lang-de { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
.lang-fr { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
.lang-it { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
.lang-en { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
```

### 3.4 Language Switcher Component

```typescript
// apps/web/src/app/shared/components/language-switcher/language-switcher.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatSelectModule } from '@angular/material/select';
import { MatOptionModule } from '@angular/material/core';
import { MatIconModule } from '@angular/material/icon';

@Component({
  selector: 'app-language-switcher',
  standalone: true,
  imports: [CommonModule, MatSelectModule, MatOptionModule, MatIconModule],
  template: `
    <div class="language-switcher">
      <mat-icon>language</mat-icon>
      <mat-select
        [value]="currentLanguage$ | async"
        (selectionChange)="onLanguageChange($event.value)"
        class="language-select">

        <mat-option *ngFor="let lang of supportedLanguages" [value]="lang">
          <div class="language-option">
            <span class="flag flag-{{lang}}"></span>
            <span class="language-name">{{getLanguageName(lang)}}</span>
            <span class="language-code">({{lang.toUpperCase()}})</span>
          </div>
        </mat-option>
      </mat-select>
    </div>
  `,
  styles: [`
    .language-switcher {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }

    .language-select {
      min-width: 120px;
      color: inherit;
    }

    .language-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
    }

    .flag {
      width: 20px;
      height: 15px;
      border-radius: 2px;
      background-size: cover;
    }

    .flag-de { background-image: url('/assets/flags/de.svg'); }
    .flag-fr { background-image: url('/assets/flags/fr.svg'); }
    .flag-it { background-image: url('/assets/flags/it.svg'); }
    .flag-en { background-image: url('/assets/flags/gb.svg'); }

    .language-name {
      font-weight: 500;
    }

    .language-code {
      font-size: 0.85em;
      opacity: 0.7;
    }
  `]
})
export class LanguageSwitcherComponent {
  currentLanguage$ = this.languageService.currentLanguage$;
  supportedLanguages = this.languageService.getSupportedLanguages();

  constructor(private languageService: LanguageService) {}

  onLanguageChange(language: SupportedLanguage): void {
    this.languageService.setLanguage(language);
  }

  getLanguageName(languageCode: SupportedLanguage): string {
    const names: Record<SupportedLanguage, string> = {
      'de': $localize`:@@language.german:Deutsch`,
      'fr': $localize`:@@language.french:FranÃ§ais`,
      'it': $localize`:@@language.italian:Italiano`,
      'en': $localize`:@@language.english:English`
    };
    return names[languageCode];
  }
}
```

---

## 4. Backend Implementation

### 4.1 Translation API Service

```typescript
// apps/api/src/handlers/translation/translate-content.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { withMiddleware } from '../../middleware';
import { TranslateClient, TranslateTextCommand } from '@aws-sdk/client-translate';
import { formatResponse } from '../../middleware/response-formatter';

interface TranslationRequest {
  text: string;
  targetLanguage: 'de' | 'fr' | 'it' | 'en';
  sourceLanguage?: string;
  context?: 'project' | 'subproject' | 'status';
}

interface TranslationResponse {
  translatedText: string;
  originalText: string;
  confidence: number;
  sourceLanguage: string;
  targetLanguage: string;
  cached: boolean;
}

const translateClient = new TranslateClient({ region: process.env.AWS_REGION });

export const handler = withMiddleware(async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
  const request: TranslationRequest = JSON.parse(event.body || '{}');

  if (!request.text || !request.targetLanguage) {
    return formatResponse(400, {
      error: 'Missing required fields: text, targetLanguage'
    }, event.requestContext.requestId);
  }

  try {
    // Check cache first
    const cachedTranslation = await checkTranslationCache(
      request.text,
      request.targetLanguage,
      request.context || 'project'
    );

    if (cachedTranslation) {
      return formatResponse(200, {
        ...cachedTranslation,
        cached: true
      }, event.requestContext.requestId);
    }

    // Perform translation with AWS Translate
    const translateCommand = new TranslateTextCommand({
      Text: request.text,
      SourceLanguageCode: request.sourceLanguage || 'auto',
      TargetLanguageCode: request.targetLanguage,
      Settings: {
        Profanity: 'MASK' // Swiss business appropriate
      }
    });

    const translationResult = await translateClient.send(translateCommand);

    const response: TranslationResponse = {
      translatedText: translationResult.TranslatedText || request.text,
      originalText: request.text,
      confidence: calculateConfidence(translationResult),
      sourceLanguage: translationResult.SourceLanguageCode || 'auto',
      targetLanguage: request.targetLanguage,
      cached: false
    };

    // Cache successful translation
    await cacheTranslation(request, response);

    return formatResponse(200, response, event.requestContext.requestId);

  } catch (error) {
    console.error('Translation failed:', error);

    // Fallback response
    return formatResponse(200, {
      translatedText: request.text,
      originalText: request.text,
      confidence: 0,
      sourceLanguage: 'unknown',
      targetLanguage: request.targetLanguage,
      cached: false,
      fallback: true
    }, event.requestContext.requestId);
  }
});

async function checkTranslationCache(
  text: string,
  targetLang: string,
  context: string
): Promise<TranslationResponse | null> {
  // Implementation with PostgreSQL cache lookup
  // Returns cached translation if available and not expired
  const query = `
    SELECT translated_text, confidence_score, source_language, created_at
    FROM translation_cache
    WHERE original_text = $1
      AND target_language = $2
      AND translation_context = $3
      AND expires_at > NOW()
  `;

  // Execute query and return result if found
  return null; // Placeholder
}

async function cacheTranslation(
  request: TranslationRequest,
  response: TranslationResponse
): Promise<void> {
  // Implementation to store translation in cache table
  const query = `
    INSERT INTO translation_cache (
      original_text, translated_text, source_language, target_language,
      translation_context, confidence_score, provider, expires_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    ON CONFLICT (original_text, target_language, translation_context)
    DO UPDATE SET
      translated_text = EXCLUDED.translated_text,
      confidence_score = EXCLUDED.confidence_score,
      expires_at = EXCLUDED.expires_at
  `;

  // Execute insert query
}

function calculateConfidence(result: any): number {
  // AWS Translate doesn't provide confidence scores directly
  // Implement heuristics based on text length, language pairs, etc.
  return 0.85; // Default confidence for AWS Translate
}
```

### 4.2 User Language Preferences API

```typescript
// apps/api/src/handlers/user/language-preferences.ts
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { withMiddleware } from '../../middleware';
import { formatResponse } from '../../middleware/response-formatter';

// GET /api/user/language-preference
export const getUserLanguagePreference = withMiddleware(async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
  const userId = event.requestContext.authorizer?.claims?.sub;

  if (!userId) {
    return formatResponse(401, { error: 'Unauthorized' }, event.requestContext.requestId);
  }

  try {
    const query = `
      SELECT preferred_language, date_format_preference, number_format_preference, currency_display
      FROM user_language_preferences
      WHERE user_id = $1
    `;

    // Execute query and return user preferences
    const result = await executeQuery(query, [userId]);

    if (result.rows.length === 0) {
      // Return default preferences if none set
      return formatResponse(200, {
        preferredLanguage: 'en',
        dateFormatPreference: 'DD.MM.YYYY',
        numberFormatPreference: 'CH',
        currencyDisplay: 'CHF'
      }, event.requestContext.requestId);
    }

    const preferences = result.rows[0];
    return formatResponse(200, {
      preferredLanguage: preferences.preferred_language,
      dateFormatPreference: preferences.date_format_preference,
      numberFormatPreference: preferences.number_format_preference,
      currencyDisplay: preferences.currency_display
    }, event.requestContext.requestId);

  } catch (error) {
    console.error('Failed to get user language preference:', error);
    return formatResponse(500, { error: 'Internal server error' }, event.requestContext.requestId);
  }
});

// PUT /api/user/language-preference
export const updateUserLanguagePreference = withMiddleware(async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {
  const userId = event.requestContext.authorizer?.claims?.sub;
  const { language, dateFormat, numberFormat, currencyDisplay } = JSON.parse(event.body || '{}');

  if (!userId) {
    return formatResponse(401, { error: 'Unauthorized' }, event.requestContext.requestId);
  }

  if (!language || !['de', 'fr', 'it', 'en'].includes(language)) {
    return formatResponse(400, { error: 'Invalid language code' }, event.requestContext.requestId);
  }

  try {
    const query = `
      INSERT INTO user_language_preferences (
        user_id, preferred_language, date_format_preference,
        number_format_preference, currency_display, updated_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      ON CONFLICT (user_id)
      DO UPDATE SET
        preferred_language = EXCLUDED.preferred_language,
        date_format_preference = EXCLUDED.date_format_preference,
        number_format_preference = EXCLUDED.number_format_preference,
        currency_display = EXCLUDED.currency_display,
        updated_at = NOW()
    `;

    await executeQuery(query, [
      userId,
      language,
      dateFormat || 'DD.MM.YYYY',
      numberFormat || 'CH',
      currencyDisplay || 'CHF'
    ]);

    return formatResponse(200, {
      message: 'Language preference updated successfully'
    }, event.requestContext.requestId);

  } catch (error) {
    console.error('Failed to update user language preference:', error);
    return formatResponse(500, { error: 'Internal server error' }, event.requestContext.requestId);
  }
});
```

---

## 5. Database Schema

### 5.1 User Language Preferences

```sql
-- Migration: 001_add_multilingual_support.sql
BEGIN;

-- User language preferences
CREATE TABLE user_language_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES employees(id) ON DELETE CASCADE,
  preferred_language VARCHAR(2) NOT NULL CHECK (preferred_language IN ('de', 'fr', 'it', 'en')),
  date_format_preference VARCHAR(20) DEFAULT 'DD.MM.YYYY',
  number_format_preference VARCHAR(20) DEFAULT 'CH',
  currency_display VARCHAR(10) DEFAULT 'CHF',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  UNIQUE(user_id)
);

-- Translation cache for dynamic content
CREATE TABLE translation_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  original_text TEXT NOT NULL,
  translated_text TEXT NOT NULL,
  source_language VARCHAR(2) DEFAULT 'auto',
  target_language VARCHAR(2) NOT NULL CHECK (target_language IN ('de', 'fr', 'it', 'en')),
  translation_context VARCHAR(50) NOT NULL,
  confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  provider VARCHAR(50) NOT NULL DEFAULT 'aws-translate',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '30 days'),

  UNIQUE(original_text, target_language, translation_context)
);

-- Indexes for performance
CREATE INDEX idx_translation_cache_lookup ON translation_cache(original_text, target_language, translation_context);
CREATE INDEX idx_translation_cache_expiry ON translation_cache(expires_at);
CREATE INDEX idx_user_language_prefs_user ON user_language_preferences(user_id);

-- Pre-populate language preferences for existing users
INSERT INTO user_language_preferences (user_id, preferred_language)
SELECT id, 'en' FROM employees
WHERE id NOT IN (SELECT user_id FROM user_language_preferences);

-- Cleanup expired translations (run periodically)
CREATE OR REPLACE FUNCTION cleanup_expired_translations()
RETURNS void AS $$
BEGIN
  DELETE FROM translation_cache WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

---

## 6. Angular i18n Configuration

### 6.1 Angular.json Configuration

```json
{
  "projects": {
    "web": {
      "i18n": {
        "sourceLocale": "en",
        "locales": {
          "de": "src/locale/messages.de.xlf",
          "fr": "src/locale/messages.fr.xlf",
          "it": "src/locale/messages.it.xlf"
        }
      },
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "localize": true,
            "outputPath": "dist/web",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            "assets": [
              "src/favicon.ico",
              "src/assets"
            ],
            "styles": [
              "@angular/material/prebuilt-themes/azure-blue.css",
              "src/styles.scss"
            ]
          },
          "configurations": {
            "production": {
              "localize": true,
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kb",
                  "maximumError": "1mb"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "2kb",
                  "maximumError": "4kb"
                }
              ],
              "outputHashing": "all"
            },
            "de": {
              "localize": ["de"],
              "outputPath": "dist/web/de"
            },
            "fr": {
              "localize": ["fr"],
              "outputPath": "dist/web/fr"
            },
            "it": {
              "localize": ["it"],
              "outputPath": "dist/web/it"
            }
          }
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "web:build:production"
            },
            "de": {
              "buildTarget": "web:build:de"
            },
            "fr": {
              "buildTarget": "web:build:fr"
            },
            "it": {
              "buildTarget": "web:build:it"
            }
          }
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n",
          "options": {
            "buildTarget": "web:build"
          }
        }
      }
    }
  }
}
```

### 6.2 Package.json Scripts

```json
{
  "scripts": {
    "start": "ng serve",
    "start:de": "ng serve --configuration=de --port=4201",
    "start:fr": "ng serve --configuration=fr --port=4202",
    "start:it": "ng serve --configuration=it --port=4203",
    "build": "ng build --localize",
    "build:de": "ng build --configuration=de",
    "build:fr": "ng build --configuration=fr",
    "build:it": "ng build --configuration=it",
    "extract-i18n": "ng extract-i18n",
    "translate:update": "npm run extract-i18n && echo 'Update translation files in src/locale/'",
    "serve:all-languages": "concurrently \"npm run start\" \"npm run start:de\" \"npm run start:fr\" \"npm run start:it\"",
    "build:all-languages": "npm run build:de && npm run build:fr && npm run build:it"
  }
}
```

### 6.3 Sample Translation Files

**German (messages.de.xlf):**
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <file source-language="en" datatype="plaintext" original="ng2.template">
    <body>
      <trans-unit id="employee.dashboard.title" datatype="html">
        <source>Travel Requests Dashboard</source>
        <target>ReiseantrÃ¤ge Dashboard</target>
      </trans-unit>
      <trans-unit id="employee.dashboard.new-request" datatype="html">
        <source>New Travel Request</source>
        <target>Neuer Reiseantrag</target>
      </trans-unit>
      <trans-unit id="manager.dashboard.approve-selected" datatype="html">
        <source>Approve Selected</source>
        <target>AusgewÃ¤hlte Genehmigen</target>
      </trans-unit>
      <trans-unit id="table.header.project" datatype="html">
        <source>Project</source>
        <target>Projekt</target>
      </trans-unit>
      <trans-unit id="table.header.status" datatype="html">
        <source>Status</source>
        <target>Status</target>
      </trans-unit>
      <trans-unit id="status.pending" datatype="html">
        <source>Pending</source>
        <target>Ausstehend</target>
      </trans-unit>
      <trans-unit id="status.approved" datatype="html">
        <source>Approved</source>
        <target>Genehmigt</target>
      </trans-unit>
      <trans-unit id="status.rejected" datatype="html">
        <source>Rejected</source>
        <target>Abgelehnt</target>
      </trans-unit>
      <trans-unit id="language.german" datatype="html">
        <source>Deutsch</source>
        <target>Deutsch</target>
      </trans-unit>
      <trans-unit id="language.french" datatype="html">
        <source>FranÃ§ais</source>
        <target>FranzÃ¶sisch</target>
      </trans-unit>
      <trans-unit id="language.italian" datatype="html">
        <source>Italiano</source>
        <target>Italienisch</target>
      </trans-unit>
      <trans-unit id="language.english" datatype="html">
        <source>English</source>
        <target>Englisch</target>
      </trans-unit>
    </body>
  </file>
</xliff>
```

**French (messages.fr.xlf):**
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <file source-language="en" datatype="plaintext" original="ng2.template">
    <body>
      <trans-unit id="employee.dashboard.title" datatype="html">
        <source>Travel Requests Dashboard</source>
        <target>Tableau de Bord des Demandes de Voyage</target>
      </trans-unit>
      <trans-unit id="employee.dashboard.new-request" datatype="html">
        <source>New Travel Request</source>
        <target>Nouvelle Demande de Voyage</target>
      </trans-unit>
      <trans-unit id="manager.dashboard.approve-selected" datatype="html">
        <source>Approve Selected</source>
        <target>Approuver SÃ©lectionnÃ©s</target>
      </trans-unit>
      <trans-unit id="table.header.project" datatype="html">
        <source>Project</source>
        <target>Projet</target>
      </trans-unit>
      <trans-unit id="table.header.status" datatype="html">
        <source>Status</source>
        <target>Statut</target>
      </trans-unit>
      <trans-unit id="status.pending" datatype="html">
        <source>Pending</source>
        <target>En Attente</target>
      </trans-unit>
      <trans-unit id="status.approved" datatype="html">
        <source>Approved</source>
        <target>ApprouvÃ©</target>
      </trans-unit>
      <trans-unit id="status.rejected" datatype="html">
        <source>Rejected</source>
        <target>RejetÃ©</target>
      </trans-unit>
    </body>
  </file>
</xliff>
```

---

## 7. Infrastructure Updates

### 7.1 Lambda Stack Updates

```typescript
// infrastructure/lib/lambda-stack.ts
export class LambdaStack extends Stack {
  // ... existing functions

  // Add translation function
  public translationFunction!: lambda.Function;
  public getUserLanguageFunction!: lambda.Function;
  public updateUserLanguageFunction!: lambda.Function;

  constructor(scope: Construct, id: string, props: LambdaStackProps) {
    super(scope, id, props);

    // ... existing function definitions

    // Translation service function
    this.translationFunction = new lambda.Function(this, 'TranslationFunction', {
      runtime: lambda.Runtime.NODEJS_20_X,
      handler: 'handlers/translation/translate-content.handler',
      code: lambda.Code.fromAsset('apps/api/dist'),
      environment: {
        ...baseEnv,
        AWS_TRANSLATE_REGION: 'eu-central-1'
      },
      timeout: cdk.Duration.seconds(30),
      memorySize: 512, // Higher memory for translation processing
      logRetention: logs.RetentionDays.ONE_WEEK,
    });

    // User language preference functions
    this.getUserLanguageFunction = new lambda.Function(this, 'GetUserLanguageFunction', {
      runtime: lambda.Runtime.NODEJS_20_X,
      handler: 'handlers/user/language-preferences.getUserLanguagePreference',
      code: lambda.Code.fromAsset('apps/api/dist'),
      environment: baseEnv,
      timeout: cdk.Duration.seconds(15),
      memorySize: 256,
      logRetention: logs.RetentionDays.ONE_WEEK,
    });

    this.updateUserLanguageFunction = new lambda.Function(this, 'UpdateUserLanguageFunction', {
      runtime: lambda.Runtime.NODEJS_20_X,
      handler: 'handlers/user/language-preferences.updateUserLanguagePreference',
      code: lambda.Code.fromAsset('apps/api/dist'),
      environment: baseEnv,
      timeout: cdk.Duration.seconds(15),
      memorySize: 256,
      logRetention: logs.RetentionDays.ONE_WEEK,
    });

    // Grant translation permissions
    this.translationFunction.addToRolePolicy(
      new PolicyStatement({
        effect: Effect.ALLOW,
        actions: [
          'translate:TranslateText',
          'translate:ListLanguages'
        ],
        resources: ['*']
      })
    );

    // Grant database access for all language-related functions
    [this.translationFunction, this.getUserLanguageFunction, this.updateUserLanguageFunction].forEach(func => {
      func.addToRolePolicy(
        new PolicyStatement({
          effect: Effect.ALLOW,
          actions: ['rds:DescribeDBInstances'],
          resources: [props.databaseArn]
        })
      );
    });

    // Export function ARNs
    new cdk.CfnOutput(this, 'TranslationFunctionArnOutput', {
      value: this.translationFunction.functionArn,
      exportName: `rtm-${environment}-translation-function-arn`,
    });

    new cdk.CfnOutput(this, 'GetUserLanguageFunctionArnOutput', {
      value: this.getUserLanguageFunction.functionArn,
      exportName: `rtm-${environment}-get-user-language-function-arn`,
    });

    new cdk.CfnOutput(this, 'UpdateUserLanguageFunctionArnOutput', {
      value: this.updateUserLanguageFunction.functionArn,
      exportName: `rtm-${environment}-update-user-language-function-arn`,
    });
  }
}
```

### 7.2 API Gateway Stack Updates

```typescript
// infrastructure/lib/api-gateway-stack.ts
export class ApiGatewayStack extends Stack {
  constructor(scope: Construct, id: string, props: ApiGatewayStackProps) {
    super(scope, id, props);

    // ... existing function imports

    // Import translation functions
    const translationFunction = lambda.Function.fromFunctionAttributes(this, 'ImportedTranslationFunction', {
      functionArn: cdk.Fn.importValue(`rtm-${environment}-translation-function-arn`),
      sameEnvironment: true,
    });

    const getUserLanguageFunction = lambda.Function.fromFunctionAttributes(this, 'ImportedGetUserLanguageFunction', {
      functionArn: cdk.Fn.importValue(`rtm-${environment}-get-user-language-function-arn`),
      sameEnvironment: true,
    });

    const updateUserLanguageFunction = lambda.Function.fromFunctionAttributes(this, 'ImportedUpdateUserLanguageFunction', {
      functionArn: cdk.Fn.importValue(`rtm-${environment}-update-user-language-function-arn`),
      sameEnvironment: true,
    });

    // ... existing route definitions

    // Translation API routes
    const translationIntegration = new LambdaIntegration(translationFunction);

    const translationResource = api.root.addResource('translation');
    translationResource.addMethod('POST', translationIntegration, {
      authorizer: cognitoAuthorizer,
      authorizationType: AuthorizationType.COGNITO,
    });

    // User language preference routes
    const userResource = api.root.addResource('user');
    const languageResource = userResource.addResource('language-preference');

    const getUserLanguageIntegration = new LambdaIntegration(getUserLanguageFunction);
    const updateUserLanguageIntegration = new LambdaIntegration(updateUserLanguageFunction);

    languageResource.addMethod('GET', getUserLanguageIntegration, {
      authorizer: cognitoAuthorizer,
      authorizationType: AuthorizationType.COGNITO,
    });

    languageResource.addMethod('PUT', updateUserLanguageIntegration, {
      authorizer: cognitoAuthorizer,
      authorizationType: AuthorizationType.COGNITO,
    });
  }
}
```

### 7.3 Web Stack Updates for Multi-language Builds

```typescript
// infrastructure/lib/web-stack.ts
export class WebStack extends Stack {
  constructor(scope: Construct, id: string, props: WebStackProps) {
    super(scope, id, props);

    // ... existing configuration

    // Create S3 deployment for each language
    const languages = ['en', 'de', 'fr', 'it'];

    languages.forEach(lang => {
      const langDeployment = new s3deploy.BucketDeployment(this, `WebDeployment${lang.toUpperCase()}`, {
        sources: [s3deploy.Source.asset(`apps/web/dist/web/${lang}`)],
        destinationBucket: websiteBucket,
        destinationKeyPrefix: lang === 'en' ? '' : `${lang}/`, // English as default, others in subdirectories
        distribution: cloudFrontDistribution,
        distributionPaths: [`/${lang}/*`],
        memoryLimit: 1024, // Increase memory for large builds
      });
    });

    // Update CloudFront behaviors for language routing
    cloudFrontDistribution.addBehavior('/de/*', websiteOrigin, {
      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      cachePolicy: CachePolicy.CACHING_OPTIMIZED,
      compress: true,
    });

    cloudFrontDistribution.addBehavior('/fr/*', websiteOrigin, {
      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      cachePolicy: CachePolicy.CACHING_OPTIMIZED,
      compress: true,
    });

    cloudFrontDistribution.addBehavior('/it/*', websiteOrigin, {
      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      cachePolicy: CachePolicy.CACHING_OPTIMIZED,
      compress: true,
    });

    // Add language detection edge function (optional)
    const languageDetectionFunction = new cloudfront.Function(this, 'LanguageDetectionFunction', {
      code: cloudfront.FunctionCode.fromInline(`
        function handler(event) {
          var request = event.request;
          var headers = request.headers;
          var uri = request.uri;

          // Don't redirect API calls or assets
          if (uri.startsWith('/api/') || uri.startsWith('/assets/')) {
            return request;
          }

          // Check if language is already in path
          if (uri.match(/^\/(de|fr|it)\//)) {
            return request;
          }

          // Get preferred language from Accept-Language header
          var acceptLanguage = headers['accept-language'];
          if (acceptLanguage) {
            var preferredLang = acceptLanguage.value.split(',')[0].split('-')[0];
            if (['de', 'fr', 'it'].includes(preferredLang)) {
              request.uri = '/' + preferredLang + uri;
            }
          }

          return request;
        }
      `),
    });

    // Apply language detection to default behavior
    cloudFrontDistribution.addBehavior('/', websiteOrigin, {
      viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      cachePolicy: CachePolicy.CACHING_OPTIMIZED,
      functionAssociations: [{
        function: languageDetectionFunction,
        eventType: cloudfront.FunctionEventType.VIEWER_REQUEST,
      }],
    });
  }
}
```

---

## 8. Template Usage Examples

### 8.1 Employee Dashboard Component

```typescript
// apps/web/src/app/features/employee/components/employee-dashboard.component.ts
@Component({
  selector: 'app-employee-dashboard',
  template: `
    <div class="dashboard-header">
      <h1 i18n="@@employee.dashboard.title">Travel Requests Dashboard</h1>
      <p i18n="@@employee.dashboard.description">
        View and manage your travel allowance requests
      </p>

      <!-- Language Switcher -->
      <app-language-switcher></app-language-switcher>
    </div>

    <div class="dashboard-actions">
      <button mat-raised-button color="primary"
              (click)="createNewRequest()"
              i18n="@@employee.dashboard.new-request">
        New Travel Request
      </button>
    </div>

    <div class="requests-table">
      <h2 i18n="@@employee.dashboard.recent-requests">Recent Requests</h2>

      <mat-table [dataSource]="requests$">
        <ng-container matColumnDef="project">
          <mat-header-cell *matHeaderCellDef i18n="@@table.header.project">
            Project
          </mat-header-cell>
          <mat-cell *matCellDef="let request">
            <!-- Dynamic content with translation directive -->
            <span appTranslate="{{request.projectName}}"
                  translationContext="project"
                  [showTooltip]="true"
                  [showConfidence]="false"></span>
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="subproject">
          <mat-header-cell *matHeaderCellDef i18n="@@table.header.subproject">
            Location
          </mat-header-cell>
          <mat-cell *matCellDef="let request">
            <span appTranslate="{{request.subprojectName}}"
                  translationContext="subproject"
                  [showTooltip]="true"></span>
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="status">
          <mat-header-cell *matHeaderCellDef i18n="@@table.header.status">
            Status
          </mat-header-cell>
          <mat-cell *matCellDef="let request">
            <span [class]="'status-' + request.status"
                  i18n="@@status.{{request.status}}">
              {{request.status | titlecase}}
            </span>
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="amount">
          <mat-header-cell *matHeaderCellDef i18n="@@table.header.amount">
            Daily Amount
          </mat-header-cell>
          <mat-cell *matCellDef="let request">
            <span class="amount">
              {{request.dailyAllowance | currency:'CHF':'symbol':'1.2-2':'de-CH'}}
            </span>
          </mat-cell>
        </ng-container>
      </mat-table>
    </div>
  `,
  styles: [`
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .status-pending { color: #ff9800; }
    .status-approved { color: #4caf50; }
    .status-rejected { color: #f44336; }

    .amount {
      font-weight: 500;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
  `]
})
export class EmployeeDashboardComponent implements OnInit {
  requests$ = this.employeeService.getRequests();

  constructor(private employeeService: EmployeeService) {}

  ngOnInit(): void {
    // Component initialization
  }

  createNewRequest(): void {
    // Navigate to new request form
  }
}
```

### 8.2 Travel Request Form with Dynamic Translation

```typescript
// apps/web/src/app/features/employee/components/travel-request-form.component.ts
@Component({
  selector: 'app-travel-request-form',
  template: `
    <form [formGroup]="requestForm" (ngSubmit)="onSubmit()">
      <h2 i18n="@@travel-request.form.title">New Travel Request</h2>

      <mat-form-field appearance="outline">
        <mat-label i18n="@@travel-request.form.project">Project</mat-label>
        <mat-select formControlName="projectId" (selectionChange)="onProjectChange($event)">
          <mat-option *ngFor="let project of projects$ | async" [value]="project.id">
            <!-- Project name with translation -->
            <span appTranslate="{{project.name}}"
                  translationContext="project"
                  [showTooltip]="true"></span>
          </mat-option>
        </mat-select>
      </mat-form-field>

      <mat-form-field appearance="outline" *ngIf="subprojects$ | async as subprojects">
        <mat-label i18n="@@travel-request.form.subproject">Location</mat-label>
        <mat-select formControlName="subprojectId">
          <mat-option *ngFor="let subproject of subprojects" [value]="subproject.id">
            <!-- Subproject name with translation -->
            <span appTranslate="{{subproject.name}}"
                  translationContext="subproject"
                  [showTooltip]="true"></span>
            <span class="location-details">
              ({{subproject.address?.city}}, {{subproject.costPerKm | currency:'CHF':'symbol':'1.2-2':'de-CH'}}/km)
            </span>
          </mat-option>
        </mat-select>
      </mat-form-field>

      <mat-form-field appearance="outline">
        <mat-label i18n="@@travel-request.form.days-per-week">Days per Week</mat-label>
        <mat-select formControlName="daysPerWeek">
          <mat-option value="1" i18n="@@travel-request.form.days.one">1 Day</mat-option>
          <mat-option value="2" i18n="@@travel-request.form.days.two">2 Days</mat-option>
          <mat-option value="3" i18n="@@travel-request.form.days.three">3 Days</mat-option>
          <mat-option value="4" i18n="@@travel-request.form.days.four">4 Days</mat-option>
          <mat-option value="5" i18n="@@travel-request.form.days.five">5 Days</mat-option>
        </mat-select>
      </mat-form-field>

      <mat-form-field appearance="outline">
        <mat-label i18n="@@travel-request.form.justification">Justification</mat-label>
        <textarea matInput
                  formControlName="justification"
                  rows="4"
                  maxlength="500"
                  i18n-placeholder="@@travel-request.form.justification.placeholder">
        </textarea>
        <mat-hint align="end">{{requestForm.get('justification')?.value?.length || 0}}/500</mat-hint>
      </mat-form-field>

      <!-- Real-time calculation display -->
      <div class="calculation-preview" *ngIf="calculationResult$ | async as calc">
        <h3 i18n="@@travel-request.calculation.title">Calculation Preview</h3>
        <div class="calc-row">
          <span i18n="@@travel-request.calculation.distance">Distance:</span>
          <span>{{calc.distance | number:'1.1-1'}} km</span>
        </div>
        <div class="calc-row">
          <span i18n="@@travel-request.calculation.rate">Rate:</span>
          <span>{{calc.costPerKm | currency:'CHF':'symbol':'1.2-2':'de-CH'}}/km</span>
        </div>
        <div class="calc-row total">
          <span i18n="@@travel-request.calculation.daily-amount">Daily Amount:</span>
          <span>{{calc.dailyAmount | currency:'CHF':'symbol':'1.2-2':'de-CH'}}</span>
        </div>
        <div class="calc-row total">
          <span i18n="@@travel-request.calculation.weekly-amount">Weekly Amount:</span>
          <span>{{calc.weeklyAmount | currency:'CHF':'symbol':'1.2-2':'de-CH'}}</span>
        </div>
      </div>

      <div class="form-actions">
        <button type="button"
                mat-button
                (click)="onCancel()"
                i18n="@@travel-request.form.cancel">
          Cancel
        </button>
        <button type="submit"
                mat-raised-button
                color="primary"
                [disabled]="requestForm.invalid || isSubmitting"
                i18n="@@travel-request.form.submit">
          Submit Request
        </button>
      </div>
    </form>
  `,
  styles: [`
    .calculation-preview {
      background: #f5f5f5;
      padding: 16px;
      border-radius: 8px;
      margin: 16px 0;
    }

    .calc-row {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
    }

    .calc-row.total {
      font-weight: 500;
      border-top: 1px solid #ddd;
      padding-top: 8px;
    }

    .location-details {
      font-size: 0.85em;
      color: #666;
      margin-left: 8px;
    }

    .form-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }
  `]
})
export class TravelRequestFormComponent implements OnInit {
  requestForm = this.fb.group({
    projectId: ['', Validators.required],
    subprojectId: ['', Validators.required],
    daysPerWeek: ['', Validators.required],
    justification: ['', [Validators.required, Validators.minLength(10), Validators.maxLength(500)]]
  });

  projects$ = this.projectService.getActiveProjects();
  subprojects$ = this.projectService.getSubprojectsForProject(this.requestForm.get('projectId')?.value);
  calculationResult$ = combineLatest([
    this.requestForm.get('subprojectId')!.valueChanges,
    this.requestForm.get('daysPerWeek')!.valueChanges
  ]).pipe(
    switchMap(([subprojectId, daysPerWeek]) =>
      this.calculationService.calculateAllowance(subprojectId, daysPerWeek)
    )
  );

  isSubmitting = false;

  constructor(
    private fb: FormBuilder,
    private projectService: ProjectService,
    private calculationService: CalculationService,
    private travelRequestService: TravelRequestService,
    private router: Router
  ) {}

  ngOnInit(): void {
    // Form initialization
  }

  onProjectChange(event: any): void {
    this.requestForm.patchValue({ subprojectId: '' });
    this.subprojects$ = this.projectService.getSubprojectsForProject(event.value);
  }

  async onSubmit(): Promise<void> {
    if (this.requestForm.valid) {
      this.isSubmitting = true;
      try {
        await this.travelRequestService.submitRequest(this.requestForm.value);
        this.router.navigate(['/employee/dashboard']);
      } catch (error) {
        console.error('Failed to submit request:', error);
      } finally {
        this.isSubmitting = false;
      }
    }
  }

  onCancel(): void {
    this.router.navigate(['/employee/dashboard']);
  }
}
```

---

## 9. Implementation Timeline & Roadmap

### 9.1 Phase-by-Phase Implementation (6-8 weeks)

| Phase | Duration | Key Deliverables | Dependencies |
|-------|----------|------------------|--------------|
| **Phase 1: Foundation** | 2-3 weeks | Angular i18n setup, core language service, basic UI translations | None |
| **Phase 2: Dynamic Translation** | 2 weeks | AWS Translate integration, translation API, dynamic content directive | Phase 1 |
| **Phase 3: User Experience** | 1 week | Language switcher, user preferences, database migration | Phase 2 |
| **Phase 4: Optimization** | 1-2 weeks | Testing, performance optimization, deployment automation | Phase 3 |

### 9.2 Phase 1: Foundation (Weeks 1-3)

**Week 1:**
- Install Angular i18n packages (`@angular/localize`)
- Configure `angular.json` for multiple locales
- Set up build configurations for each language
- Create basic `LanguageService` with LocalStorage persistence

**Week 2:**
- Mark static UI text with i18n attributes in high-priority components
- Extract translation messages (`ng extract-i18n`)
- Create initial translation files for DE, FR, IT
- Implement basic language switcher component

**Week 3:**
- Complete static text translation for all major components
- Test multi-language builds
- Set up development scripts for language-specific serving
- Documentation for translation workflow

**Deliverables:**
- âœ… Angular i18n fully configured
- âœ… Language switcher component
- âœ… Static UI text translated for all languages
- âœ… Development workflow established

### 9.3 Phase 2: Dynamic Translation (Weeks 4-5)

**Week 4:**
- Implement backend translation API with AWS Translate
- Create database schema for translation cache and user preferences
- Deploy Lambda functions for translation services
- Add API Gateway routes

**Week 5:**
- Implement `TranslateDirective` for dynamic content
- Create `TranslationApiService` for frontend-backend communication
- Add translation caching logic
- Implement tooltip functionality with original text

**Deliverables:**
- âœ… AWS Translate integration
- âœ… Dynamic content translation with tooltips
- âœ… Translation caching system
- âœ… Confidence indicators

### 9.4 Phase 3: User Experience (Week 6)

**Week 6:**
- Implement user language preference persistence
- Enhanced language switcher with flags and names
- Database migration for existing users
- User profile integration for language settings

**Deliverables:**
- âœ… Persistent user language preferences
- âœ… Enhanced language switcher UI
- âœ… Database migration completed
- âœ… User profile language settings

### 9.5 Phase 4: Optimization & Testing (Weeks 7-8)

**Week 7:**
- Performance optimization (bundle size, caching)
- Comprehensive testing across all languages
- Error handling and fallback mechanisms
- Translation quality validation

**Week 8:**
- Deployment automation for multi-language builds
- CloudFront configuration for language routing
- Documentation completion
- User acceptance testing

**Deliverables:**
- âœ… Performance optimized builds
- âœ… Comprehensive testing completed
- âœ… Deployment automation
- âœ… Production-ready multi-language application

---

## 10. Testing Strategy

### 10.1 Translation Testing

**Unit Tests:**
```typescript
// apps/web/src/app/shared/directives/translate.directive.spec.ts
describe('TranslateDirective', () => {
  let directive: TranslateDirective;
  let mockLanguageService: jasmine.SpyObj<LanguageService>;
  let mockTranslationService: jasmine.SpyObj<TranslationApiService>;

  beforeEach(() => {
    const languageSpy = jasmine.createSpyObj('LanguageService', ['currentLanguage$', 'getCurrentLanguage']);
    const translationSpy = jasmine.createSpyObj('TranslationApiService', ['translateContent']);

    TestBed.configureTestingModule({
      providers: [
        { provide: LanguageService, useValue: languageSpy },
        { provide: TranslationApiService, useValue: translationSpy }
      ]
    });

    mockLanguageService = TestBed.inject(LanguageService) as jasmine.SpyObj<LanguageService>;
    mockTranslationService = TestBed.inject(TranslationApiService) as jasmine.SpyObj<TranslationApiService>;
  });

  it('should translate text when language changes', async () => {
    const mockTranslation = {
      translatedText: 'Projekt ZÃ¼rich',
      originalText: 'Zurich Project',
      confidence: 0.95,
      language: 'de' as SupportedLanguage,
      fallback: false
    };

    mockTranslationService.translateContent.and.returnValue(of(mockTranslation));
    mockLanguageService.currentLanguage$ = of('de' as SupportedLanguage);

    // Test directive translation functionality
    expect(mockTranslationService.translateContent).toHaveBeenCalledWith({
      text: 'Zurich Project',
      targetLanguage: 'de',
      context: 'project'
    });
  });

  it('should fallback to original text on translation error', async () => {
    mockTranslationService.translateContent.and.returnValue(throwError('Translation failed'));

    // Test error handling and fallback behavior
    // Verify original text is displayed
  });

  it('should show tooltip with original text and confidence', () => {
    // Test tooltip functionality
  });
});
```

**Integration Tests:**
```typescript
// apps/web/src/app/features/employee/components/employee-dashboard.component.integration.spec.ts
describe('EmployeeDashboard Integration', () => {
  it('should display translated project names in table', async () => {
    // Setup mock data with project names
    const mockRequests = [
      { projectName: 'Zurich Office Development', subprojectName: 'Main Building' }
    ];

    // Set language to German
    languageService.setLanguage('de');

    // Verify translation directive is applied to project names
    // Check that tooltips show original text
  });

  it('should switch language and update all translated content', async () => {
    // Test complete language switching workflow
    // Verify all static and dynamic content updates
  });
});
```

### 10.2 End-to-End Testing

```typescript
// e2e/translation.e2e-spec.ts
import { test, expect } from '@playwright/test';

test.describe('Multi-language Support', () => {
  test('should switch languages and translate content', async ({ page }) => {
    await page.goto('/employee/dashboard');

    // Initial language should be English
    await expect(page.locator('h1')).toContainText('Travel Requests Dashboard');

    // Switch to German
    await page.click('[data-testid="language-switcher"]');
    await page.click('[data-testid="language-option-de"]');

    // Verify German translation
    await expect(page.locator('h1')).toContainText('ReiseantrÃ¤ge Dashboard');

    // Verify dynamic content shows tooltips
    const projectCell = page.locator('[data-testid="project-name"]').first();
    await projectCell.hover();
    await expect(page.locator('.mat-tooltip')).toBeVisible();
  });

  test('should persist language preference across sessions', async ({ page }) => {
    // Set language to French
    await page.goto('/employee/dashboard');
    await page.click('[data-testid="language-switcher"]');
    await page.click('[data-testid="language-option-fr"]');

    // Reload page
    await page.reload();

    // Verify French is still selected
    await expect(page.locator('h1')).toContainText('Tableau de Bord des Demandes de Voyage');
  });

  test('should show confidence indicators for low-quality translations', async ({ page }) => {
    // Test confidence indicator visual feedback
  });
});
```

---

## 11. Performance Considerations

### 11.1 Build Optimization

**Bundle Size Management:**
- Each language builds separately to avoid loading unused translations
- Tree-shaking removes unused i18n keys
- Lazy loading for language-specific chunks

**Bundle Analysis:**
```bash
# Analyze bundle sizes for each language
npm run build:de -- --stats-json
npx webpack-bundle-analyzer dist/web/de/stats.json

npm run build:fr -- --stats-json
npx webpack-bundle-analyzer dist/web/fr/stats.json
```

### 11.2 Runtime Performance

**Translation Caching Strategy:**
- Frontend: In-memory cache with LRU eviction
- Backend: PostgreSQL cache with 30-day TTL
- CDN: CloudFront caching for static language bundles

**Cache Configuration:**
```typescript
// Translation cache configuration
const CACHE_CONFIG = {
  frontend: {
    maxSize: 1000, // Maximum cached translations
    ttl: 24 * 60 * 60 * 1000, // 24 hours
    cleanupInterval: 60 * 60 * 1000 // 1 hour cleanup
  },
  backend: {
    ttl: 30 * 24 * 60 * 60 * 1000, // 30 days
    batchSize: 100, // Batch translation requests
    maxConcurrency: 5 // AWS Translate concurrency limit
  }
};
```

### 11.3 AWS Translate Cost Optimization

**Cost Management:**
- Cache frequently translated content
- Batch similar translation requests
- Monitor usage with CloudWatch metrics
- Set up billing alerts for unexpected usage

**Estimated Costs (Monthly):**
- 10,000 characters/day = ~300,000 characters/month
- AWS Translate: $15/million characters
- Estimated monthly cost: ~$4.50

---

## 12. Maintenance & Updates

### 12.1 Translation Workflow

**Adding New Translations:**
1. Add i18n attributes to new UI text: `i18n="@@new.translation.key"`
2. Extract messages: `npm run extract-i18n`
3. Update translation files in `src/locale/`
4. Test builds: `npm run build:all-languages`

**Translation File Management:**
- Use descriptive translation IDs with hierarchical structure
- Include context information in comments
- Version control all translation files
- Regular translation reviews with native speakers

### 12.2 Monitoring & Analytics

**Translation Quality Monitoring:**
```typescript
// Translation analytics service
@Injectable({ providedIn: 'root' })
export class TranslationAnalyticsService {
  trackTranslationUsage(originalText: string, translatedText: string, confidence: number, language: string): void {
    // Track translation quality and usage patterns
    if (confidence < 0.7) {
      this.logLowConfidenceTranslation(originalText, language, confidence);
    }
  }

  private logLowConfidenceTranslation(text: string, language: string, confidence: number): void {
    // Send to monitoring service for review
    console.warn(`Low confidence translation: ${text} -> ${language} (${confidence})`);
  }
}
```

**CloudWatch Metrics:**
- Translation API usage and errors
- Cache hit/miss ratios
- User language preference distribution
- Page load times by language

---

## 13. Security Considerations

### 13.1 Data Privacy

**Swiss Data Residency:**
- All translation caching in EU-Central-1 PostgreSQL
- AWS Translate processes data in EU region
- User language preferences stored locally

**Content Security:**
- No sensitive business data sent to translation service
- Translation cache includes expiration and cleanup
- User consent for translation features

### 13.2 Input Validation

**Translation Request Validation:**
```typescript
// Validation schema for translation requests
const translationRequestSchema = {
  text: {
    type: 'string',
    maxLength: 5000, // Prevent large translation requests
    pattern: /^[a-zA-Z0-9\s\-_.,:;!?()]+$/ // Allow safe characters only
  },
  targetLanguage: {
    type: 'string',
    enum: ['de', 'fr', 'it', 'en']
  },
  context: {
    type: 'string',
    enum: ['project', 'subproject', 'status'],
    optional: true
  }
};
```

---

## 14. Future Enhancements

### 14.1 Advanced Features

**Planned Enhancements:**
- **Regional Dialects**: Swiss German, Canadian French variations
- **Voice Translation**: Text-to-speech for accessibility
- **Contextual Translation**: Business domain-specific translation models
- **Translation Memory**: Learn from user corrections and preferences

### 14.2 Expansion Capabilities

**Multi-tenant Support:**
- Organization-specific translation glossaries
- Custom translation rules per company
- Branded language switcher themes

**AI-Powered Improvements:**
- Machine learning for translation quality scoring
- Automatic context detection for better translations
- User feedback integration for translation improvements

---

## 15. Conclusion

This comprehensive internationalization strategy transforms RegularTravelManager into a truly Swiss-market-ready application. The hybrid approach of static UI translation with Angular i18n and dynamic content translation with AWS Translate provides the best balance of performance, user experience, and maintainability.

**Key Benefits:**
- **Swiss Market Compliance**: Full support for DE/FR/IT/EN languages
- **Performance Optimized**: Build-time static translations with runtime dynamic content
- **User-Centric**: Original text tooltips, confidence indicators, persistent preferences
- **Scalable Architecture**: Caching, lazy loading, and cost-optimized AWS services
- **Maintainable**: Clear patterns, automated workflows, comprehensive testing

The implementation can begin immediately with Phase 1, delivering incremental value while building toward the complete multilingual solution. Each phase is designed to be production-deployable, ensuring continuous delivery of language support features to users.

This architecture establishes RegularTravelManager as a leader in Swiss business application localization, supporting the linguistic diversity of Switzerland while maintaining enterprise-grade performance and user experience.